# .gitignore

```
# Dependencies /node_modules # Build output /dist # Logs *.log npm-debug.log* yarn-debug.log* yarn-error.log* lerna-debug.log* # OS generated files .DS_Store .vscode/ # Vite specific .vite/
```

# Game_Layout.md

```md
## Neon Serpent: Gameplay Overview **Concept:** Neon Serpent thrusts you into a vibrant, endlessly wrapping world as a glowing serpent. It's a modern evolution of the classic snake game, challenging your reflexes against AI opponents in a visually rich environment. **Objective:** Your primary goal is survival and growth. Navigate the expansive world, consuming glowing orbs to increase your serpent's length and accumulate score. The longer you survive and the more you consume, the higher your score climbs. **The World:** * **Expansive & Wrapping:** The game takes place in a very large, square arena. There are no walls; moving off one edge instantly transports you to the opposite side, creating a seamless, continuous space. * **2.5D Parallax Background:** A dynamic video plays in the background, featuring a scene like a futuristic cave city. This background scrolls at a different rate than the foreground gameplay (parallax effect), creating a sense of depth and a 2.5D visual experience as you move the camera. * **World Boundary:** While the world wraps, a faint, dashed red line indicates the world's logical boundaries, helping you orient yourself within the vast space. **Controlling Your Serpent:** * **Continuous Movement:** Your serpent is always in motion, gliding smoothly in its current direction. * **Keyboard:** Use `WASD` or the `Arrow Keys` to dictate the direction you want your serpent to turn towards. * **Touch (Virtual Joystick):** On touch devices, simply tap and hold anywhere on the screen. A visual joystick base appears at your touch point. Drag your finger away from the center; a knob follows your finger (clamped within a visual radius). The direction you drag determines your serpent's desired heading. Releasing your finger deactivates the joystick but maintains your serpent's last direction. A small deadzone near the center prevents accidental micro-movements. **Core Mechanics:** * **Turning:** * You can't instantly reverse (180 degrees) direction. * There's a brief cooldown period after each turn, preventing overly rapid, zig-zag movements. The cooldown is slightly different and generally shorter for touch input compared to keyboard input, allowing for more responsive touch steering. * **Smart Collision Avoidance:** The game intelligently prevents you from making a turn that would cause your serpent's head to immediately collide with its own body. It looks ahead slightly and ignores a calculated number of segments right behind the head (this "safe neck" length depends on your current speed) before allowing a turn into that space. * **Growth:** * **Orbs:** Consume scattered orbs to grow longer and score points. Orbs come in different rarities (common, uncommon, rare), with rarer orbs providing significantly more growth and score. * **Defeating AI:** Eliminating an AI opponent also rewards you with substantial growth and adds their score to yours. * **Speed:** Your serpent starts at a base speed and gradually gets faster as it grows longer, increasing the challenge naturally over time. **AI Opponents:** * **Multiple Rivals:** You share the world with several other AI-controlled serpents. * **Varied Personalities:** AI serpents exhibit different behaviors: * `Gather`: Primarily focus on collecting nearby orbs. * `Hunt`: Aggressively seek out other serpents (including you). * `Coward`: Tend to flee from larger serpents while gathering orbs when safe. * **Skill Levels:** AI serpents have varying skill levels, affecting their reaction speed and how accurately they pursue targets (lower skill AI might "wobble" more). They also have logic to avoid crashing into the player's tail segments. **Collisions & Death:** * **Your Demise:** Your game ends if your serpent's head collides with: * Any part of *your own* body (excluding the safe neck segments). * Any part of an *enemy* serpent's body (excluding their short safe neck segments). * **AI Demise:** An AI serpent is destroyed if its head collides with *your* serpent's body (beyond a few initial segments). * **Respawning:** Destroyed AI serpents are removed from the game but will eventually respawn elsewhere in the world to maintain pressure. **Visuals & Feedback:** * **Neon Aesthetic:** The game features bright, glowing visuals for serpents, orbs, and effects, set against the darker, detailed background. * **Serpent Appearance:** Serpents are rendered smoothly, appearing as continuous, glowing lines with rounded heads. Player eyes indicate the current direction of travel. * **Eating Effects:** When you consume an orb, your serpent briefly flashes brighter, and a visible "pulse" or wave travels down its body from head to tail. Particle effects also burst from the point of consumption. * **Death Effects:** When a serpent dies, it disappears, often accompanied by a burst of particles. **Game Flow & UI:** * **States:** The game cycles through clear states: `Menu`, `Playing`, `Paused`, and `Game Over`. * **Menu:** Start, view controls, or (if applicable) resume/restart. Navigate with keys or clicks/taps. * **Pause:** Press `Space` or `Escape` (or tap the pause overlay) during gameplay to pause. The game freezes, and a simple overlay appears. Resume via keypress or tap. * **Game Over:** When you die, a "Game Over" screen shows your final score. Press `Space`/`Enter` or tap the overlay to return to the main menu.
```

# index.html

```html
<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Neon Serpent</title> <style> body { margin: 0; overflow: hidden; background-color: black; } #pixi-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; /* Above video, below UI */ /* pointer-events: auto; Let Pixi handle events on its canvas */ /* Note: PixiJS canvas inside will handle pointer events */ } #backgroundWrap{ position:fixed;inset:0;overflow:hidden;z-index:-1; transition:transform .5s ease; /* zoom ONLY */ will-change:transform; } #parallaxWrap{ position:absolute;inset:0; will-change:transform; /* translate ONLY */ } #backgroundVideo{ width:100%;height:100%;object-fit:cover; /* Removed position, top, left, transform-origin, transition */ } /* --- UI Menu Styles --- */ .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */ color: #00ffcc; /* Neon cyan text */ font-family: 'Courier New', Courier, monospace; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 50; /* Above canvas, below loading screen */ text-align: center; border: 2px solid #00ffcc; box-shadow: 0 0 15px #00ffcc; /* Keep border/shadow for other menus */ } /* Specific adjustments for Controls overlay */ #controlsMenu { border: none; /* Remove border from the full overlay */ box-shadow: none; /* Remove shadow from the full overlay */ background-color: rgba(0, 0, 0, 0.3); /* Make overlay slightly darker for contrast */ } /* Style for the inner content panel */ #controlsContent { background-color: rgba(10, 25, 30, 0.85); /* Dark, slightly transparent teal background */ padding: 30px 50px; border-radius: 10px; border: 1px solid #00ffcc; box-shadow: 0 0 20px rgba(0, 255, 204, 0.5); max-width: 600px; /* Limit width of the panel */ } /* Class to apply backdrop blur */ .menu-overlay.backdrop-blur { backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); /* Safari support */ } .menu-overlay.hidden { display: none; } .menu-overlay h2 { margin-bottom: 30px; font-size: 2.5em; text-shadow: 0 0 10px #00ffcc; } .menu-overlay button { background-color: transparent; border: 2px solid #00ffcc; color: #00ffcc; padding: 15px 30px; margin: 10px; font-size: 1.5em; font-family: inherit; cursor: pointer; transition: background-color 0.2s, color 0.2s, box-shadow 0.2s; min-width: 250px; /* Ensure buttons have a decent width */ } .menu-overlay button:hover, .menu-overlay button:focus { background-color: #00ffcc; color: black; box-shadow: 0 0 15px #00ffcc; outline: none; } #controlsMenu p { margin: 5px 0; font-size: 1.2em; } #controlsMenu .controls-section { margin-bottom: 20px; } #gameOverMenu .score { font-size: 1.8em; margin-bottom: 20px; color: #ff00ff; /* Neon pink for score */ text-shadow: 0 0 10px #ff00ff; } /* In-game leaderboard styles */ #pauseLeaderboard { margin-top: 20px; /* Space above leaderboard */ width: 80%; max-width: 350px; max-height: 40vh; /* Limit height */ overflow-y: auto; border: 1px solid rgba(0, 255, 204, 0.5); /* Fainter border */ padding: 10px; background-color: rgba(0, 0, 0, 0.2); /* Slightly darker background */ } #pauseLeaderboard h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.4em; color: #ff00ff; /* Neon pink title */ text-shadow: 0 0 8px #ff00ff; } #pauseLeaderboard ol { list-style: none; /* Remove default numbering */ padding: 0; margin: 0; text-align: left; } #pauseLeaderboard li { display: flex; justify-content: space-between; padding: 3px 5px; font-size: 1.1em; border-bottom: 1px dashed rgba(0, 255, 204, 0.3); } #pauseLeaderboard li:last-child { border-bottom: none; } #pauseLeaderboard .leaderboard-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 70%; /* Prevent long names from overlapping score */ } #pauseLeaderboard .leaderboard-score { font-weight: bold; color: #ffffff; /* White score */ } #pauseLeaderboard .player-score { /* Highlight player score */ color: #00ffcc; /* Neon cyan */ font-weight: bold; } /* Mini leaderboard HUD */ #inGameLeaderboard{ position:fixed;top:40px;right:10px; font-family:"Courier New",monospace; font-size:14px;line-height:1.2; color:#ff00ff;text-align:right; background:rgba(0,0,0,.25); padding:6px 10px;border:1px solid rgba(0,255,204,.4); border-radius:6px; max-width:180px;pointer-events:none; z-index:45; } #inGameLeaderboard .mini-row.player{color:#00ffcc;font-weight:bold;} /* Hide on narrow screens (<768 px) */ @media (max-width:767px){#inGameLeaderboard{display:none;}} </style> </head> <body> <div id="backgroundWrap"> <!-- zoom (CSS transition) --> <div id="parallaxWrap"> <!-- translate3d every frame --> <video id="backgroundVideo" autoplay loop muted playsinline> <source src="/cave_city_h264_compat.mp4" type="video/mp4"> </video> </div> </div> <div id="pixi-container"></div> <!-- PixiJS will add its canvas here --> <!-- Mini leaderboard HUD (hidden via media query on phones) --> <div id="inGameLeaderboard"></div> <div id="loadingScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); color: white; display: flex; justify-content: center; align-items: center; font-size: 2em; z-index: 100;"> Loading... </div> <!-- UI Menus --> <div id="mainMenu" class="menu-overlay"> <h2>Neon Serpent</h2> <button id="startGameBtn">Start New Game</button> <button id="controlsBtnMain">Controls</button> <button id="scoreboardBtn">Scoreboard</button> <!-- Placeholder --> <button id="toggleDevModeBtn" style="font-size: 1em; padding: 8px 15px; min-width: 150px; margin-top: 20px;">Toggle Dev Mode</button> <!-- Added Dev Mode Button --> </div> <div id="controlsMenu" class="menu-overlay hidden"> <div id="controlsContent"> <h2>Controls</h2> <div class="controls-section"> <p>Move: WASD or Arrow Keys</p> <p>Turn towards cursor/touch direction</p> </div> <div class="controls-section"> <p>Pause/Resume: Space Bar</p> <p>Pause Menu: Escape (Esc)</p> </div> <button id="backToMainBtnControls">Back</button> </div> </div> <div id="pauseMenu" class="menu-overlay hidden"> <h2>Paused</h2> <!-- In-game leaderboard --> <div id="pauseLeaderboard"> <h3>Leaderboard</h3> <ol id="pauseLeaderboardList"> <!-- Scores populated by JS --> <!-- Example: <li><span class="leaderboard-name player-score">Player</span><span class="leaderboard-score player-score">500</span></li> --> <!-- Example: <li><span class="leaderboard-name">AI Name</span><span class="leaderboard-score">120</span></li> --> </ol> </div> <button id="resumeGameBtn">Resume Game</button> <button id="newGameBtnPause">New Game</button> <button id="controlsBtnPause">Controls</button> </div> <div id="gameOverMenu" class="menu-overlay hidden"> <h2>Game Over</h2> <div id="finalScore" class="score">Score: 0</div> <button id="mainMenuBtnGameOver">Main Menu</button> </div> <!-- End UI Menus --> <script type="module" src="/src/main.ts"></script> </body> </html>
```

# package.json

```json
{ "name": "neonserpent_webgl", "version": "1.0.0", "main": "index.js", "scripts": { "dev": "vite --host --port 6161", "build": "vite build", "typecheck": "tsc --noEmit" }, "keywords": [], "author": "", "license": "ISC", "description": "", "devDependencies": { "@types/node": "^22.15.3", "typescript": "^5.8.3", "vite": "^6.3.3" }, "dependencies": { "pixi.js": "^8.9.1", "simplex-noise": "^4.0.3" } }
```

# public/a.png

This is a binary file of the type: Image

# public/cave_city_h264_compat.mp4

This is a binary file of the type: Binary

# public/cave_city_h264.mp4

This is a binary file of the type: Binary

# public/cave_city.mp4

This is a binary file of the type: Binary

# public/d.png

This is a binary file of the type: Image

# public/down.png

This is a binary file of the type: Image

# public/left.png

This is a binary file of the type: Image

# public/orb1.png

This is a binary file of the type: Image

# public/orb2.png

This is a binary file of the type: Image

# public/orb3.png

This is a binary file of the type: Image

# public/orbs_original.png

This is a binary file of the type: Image

# public/orbs.png

This is a binary file of the type: Image

# public/right.png

This is a binary file of the type: Image

# public/s.png

This is a binary file of the type: Image

# public/space.png

This is a binary file of the type: Image

# public/up.png

This is a binary file of the type: Image

# public/w.png

This is a binary file of the type: Image

# src/aiConstants.ts

```ts
export const AI_COUNT = 8; export const AI_BASE_SPEED = 36; // px/s export const AI_VARIANCE_SPEED = 12; // ± export const AI_VIEW_RADIUS = 600; // px export const AI_TURN_COOLDOWN_MS = 80; export const AI_NOISE = 0.15; // 0‒1 steering wobble export const AI_STATES = ['GATHER','HUNT','EVADE'] as const; export type AIState = typeof AI_STATES[number];
```

# src/AIController.ts

```ts
import { Point, SnakeState, segRadius } from './types'; // Added segRadius import import Orb from './Orb'; import { dist, distTorus } from './utils'; // Added distTorus import import { createNoise2D } from 'simplex-noise'; import { AI_VIEW_RADIUS, /* AI_TURN_COOLDOWN_MS, */ AI_NOISE, // Commented out unused import again AIState } from './aiConstants'; const noise2D = createNoise2D(); export default class AIController { private owner: SnakeState; private state: AIState = 'GATHER'; private readonly idBias: number; // private readonly reactionMs: number; // Removed unused per-bot variable private readonly viewR: number; // Per-bot view radius constructor(owner: SnakeState) { this.owner = owner; this.idBias = Math.random() * 9999; // each bot gets its own reflex delay & view range // this.reactionMs = AI_TURN_COOLDOWN_MS * (0.7 + Math.random() * 0.6); // Removed assignment this.viewR = AI_VIEW_RADIUS * (0.8 + Math.random() * 0.4); } /** Chooses a normalized steering vector once per frame */ decide(orbs: Orb[], snakes: SnakeState[], worldW: number, worldH: number, // Added world dimensions now: number): Point { // 1. pick visible objects const myHead = this.owner.segs[0]; const inViewOrbs = orbs.filter(o => o.visible && dist(o, myHead) < this.viewR); const otherSnakes = snakes.filter(s => s !== this.owner && s.visible); // Filter out non-visible snakes too // 2-A. Foresight collision check (~300 ms look-ahead) const lookAhead = 0.3 * this.owner.speed; // px const futurePos = { x: myHead.x + this.owner.velocity.vx * lookAhead, y: myHead.y + this.owner.velocity.vy * lookAhead }; const danger = snakes.some(s => s.segs .slice(6) // ignore necks .some(seg => distTorus(futurePos, seg, worldW, worldH) < // Use worldW, worldH segRadius(this.owner.length) + 2)); if (danger) this.state = 'EVADE'; // 2-B. Determine state priority: Hunt > Evade Imminent > Gather const tgtSnake = this.pickSnakeTarget(otherSnakes, myHead); const imminent = otherSnakes.find(s => s.length > this.owner.length && dist(s.segs[0], myHead) < 120 ); // Check distance to *head* of bigger snake // Update state based on priority, ensuring EVADE from danger check isn't overwritten unless a higher priority exists if (tgtSnake) { this.state = 'HUNT'; // HUNT overrides EVADE from danger check } else if (imminent) { this.state = 'EVADE'; // EVADE from imminent threat overrides EVADE from danger check } else if (this.state !== 'EVADE') { // Only change to GATHER if not already EVADING from danger if (inViewOrbs.length > 0) { this.state = 'GATHER'; } else { // Default state if no targets or threats and not evading this.state = 'GATHER'; // Default to seeking orbs } } // If state is still EVADE from the danger check, it remains EVADE // 3. Determine target point based on state let target: Point | null = null; if (this.state === 'HUNT') { target = tgtSnake!.segs.at(-2)!; // Aim at tail–1 of target snake } else if (this.state === 'GATHER') { target = this.pickBestOrb(inViewOrbs); // pickBestOrb handles empty array } else if (this.state === 'EVADE') { // Steer away from the imminent threat's head or just continue forward? if (imminent) { // Simple evasion: steer directly away from the threat's head const threatHead = imminent.segs[0]; target = { x: myHead.x + (myHead.x - threatHead.x), y: myHead.y + (myHead.y - threatHead.y) }; } else { // If EVADE state was reached from danger check (no imminent threat) // Steer opposite current velocity target = { x: myHead.x - this.owner.velocity.vx * 100, y: myHead.y - this.owner.velocity.vy * 100 }; } } // Ensure target is never null (should be guaranteed by state logic) if (!target) { console.warn(`AI ${this.owner.id} could not determine target in state ${this.state}. Defaulting to forward.`); target = { x: myHead.x + this.owner.velocity.vx, y: myHead.y + this.owner.velocity.vy }; } // 4. Calculate steering vector towards target const dir = this.vecTo(myHead, target); // 5. wobble ⇒ prevents “dodge-gods” const wobble = this.noise(now); return this.normalize({ x: dir.x + wobble.x, y: dir.y + wobble.y }); } /* ---------- helpers ---------- */ private pickSnakeTarget(snakes: SnakeState[], head: Point): SnakeState | null { let best: SnakeState | null = null, bestD = Infinity; snakes.forEach(s => { // Ensure target snake has enough segments to aim at segs.at(-2) if (s.segs.length < 3) return; const targetPoint = s.segs.at(-2)!; // Use the segment before the tail tip const d = dist(targetPoint, head); // Use this bot's specific viewR if (d < this.viewR && s.length < this.owner.length && d < bestD) { best = s; bestD = d; } }); return best; } private pickBestOrb(orbs: Orb[]): Point { // Handle case where orbs array might be empty after filtering if (orbs.length === 0) { // Default behavior: return a point straight ahead if no orbs are visible return { x: this.owner.segs[0].x + this.owner.velocity.vx, y: this.owner.segs[0].y + this.owner.velocity.vy }; } // Find the orb with the highest value return orbs.reduce((p,c)=>(c.value>p.value?c:p)); } private vecTo(from: Point, to: Point): Point { return { x: to.x - from.x, y: to.y - from.y }; } private normalize(v: Point): Point { const l = Math.hypot(v.x, v.y) || 1; return { x: v.x/l, y: v.y/l }; } private noise(t: number): Point { // 0-1 converted to wobble range return { x: (noise2D(this.idBias, t*0.0005))*AI_NOISE, y: (noise2D(this.idBias+1111, t*0.0005))*AI_NOISE }; } }
```

# src/aiNames.ts

```ts
// Placeholder lists for AI name generation. // IMPORTANT: Replace these placeholders with your desired terms. // Using offensive terms is against safety guidelines. export const GAY_NOUNS = [ 'MuscleCub','PowerBottom','Otter','LeatherDaddy','GymBunny', 'DiscoTwink','CircuitQueen','PupHandler','BearHugger','StoneButch', 'SteamRoomDoc','PrideDiva','LubeLord','LockerLegend','SaunaScout', 'FlexFiend','ThiccIcon','GluteGuru','JockstrapJester','RainbowRogue', 'ChestChamp','ThirstTrap','ShowerSiren','KinkKnight','SquatSquire', 'BeefcakeBaron','TwerkTroll','GogoGoblin','TugBoat','GlitterGhoul' ] as const; export const GAY_VERBS = [ 'Pounder','Pleaser','Rimmer','Grinder','Stroker', 'Slurper','Sniffer','Worshiper','Luster','Explorer', 'Teaser','Taster','Wrestler','Nibbler','Hunter', 'Chaser','Churner','Milker','Thruster','Squeezer', 'Nuzzler','Hugger','Tugger','Licker','Sucker', 'Digger','Diver','Rider','Peeper','Muncher' ] as const; /** * Generates a random AI name by combining a term and a verb. * @returns A randomly generated name string. */ export function generateAiName(): string { // Use the correct array names GAY_NOUNS and GAY_VERBS const randomTerm = GAY_NOUNS[Math.floor(Math.random() * GAY_NOUNS.length)]; const randomVerb = GAY_VERBS[Math.floor(Math.random() * GAY_VERBS.length)]; return `${randomTerm} ${randomVerb}`; }
```

# src/AISerpent.ts

```ts
import AIController from './AIController'; import PlayerSerpent from './PlayerSerpent'; // default export // Fixed import import { /* Point, */ SnakeState } from './types'; // Commented out unused Point import import { AI_BASE_SPEED, AI_VARIANCE_SPEED, AI_TURN_COOLDOWN_MS } from './aiConstants'; import Orb from './Orb'; // Added Orb import for type checking in updateAI import { generateAiName } from './aiNames'; // Import name generator export default class AISerpent extends PlayerSerpent { private ai: AIController; constructor(x: number, y: number, hue: number) { super(x, y); this.isPlayer = false; this.color = hue; this.baseSpeed = AI_BASE_SPEED + (Math.random()*AI_VARIANCE_SPEED - AI_VARIANCE_SPEED/2); this.speed = this.baseSpeed; this.id = `ai-${Math.random().toString(36).slice(2)}`; this.name = generateAiName(); // Assign generated name // Cast 'this' to SnakeState for the AIController constructor // This assumes AISerpent fulfills the SnakeState interface requirements this.ai = new AIController(this as unknown as SnakeState); } // Explicitly type parameters for clarity and type safety updateAI(delta: number, now: number, orbs: Orb[], snakes: SnakeState[], worldW: number, worldH: number): void { // 1. steering const desired = this.ai.decide(orbs, snakes, worldW, worldH, now); // Pass worldW and worldH this.attemptTurn(desired, now, AI_TURN_COOLDOWN_MS); // Use AI's reaction time? No, keep global constant for now. // 2. physics & rendering (reuse parent) super.update(delta, worldW, worldH); // Optional polish: bump AI speed with length this.baseSpeed = AI_BASE_SPEED + Math.min(this.length,200)*0.15; // simple scale } }
```

# src/CollisionSystem.ts

```ts
import { SnakeState, segRadius } from './types'; // Import SnakeState and segRadius from types import { dist, distTorus } from './utils'; // Import dist and distTorus from utils import EntityManager from './EntityManager'; // Import EntityManager for type hint // import PlayerSerpent from './PlayerSerpent'; // Removed unused import // import AISerpent from './AISerpent'; // Removed unused import // Define callback function types for clarity type KillCallback = (snake: SnakeState) => void; type AbsorbCallback = (winner: SnakeState, loser: SnakeState) => void; /** * Resolves collisions between snake heads and bodies. * @param manager The EntityManager instance containing all game entities. * @param worldW The width of the game world. * @param worldH The height of the game world. * @param killCb Callback function to execute when a snake should be killed. * @param absorbCb Callback function to execute when a snake absorbs another. */ export function resolveCollisions( manager: EntityManager, _worldW: number, // Prefixed unused parameter _worldH: number, // Prefixed unused parameter killCb: KillCallback, absorbCb: AbsorbCallback ): void { const snakes = manager.getAllSnakes(); /* head-vs-body all-pairs, O(n²) <= small counts */ snakes.forEach(attacker => { // Ensure attacker is alive before checking collisions if (!attacker.visible) return; const head = attacker.segs[0]; const atkRad = segRadius(attacker.length); snakes.forEach(victim => { // Ensure victim is alive and not the attacker itself if (!victim.visible || attacker === victim) return; // const victimRad = segRadius(victim.length); // Removed unused variable victim.segs.forEach((seg, idx) => { // Skip the neck segments for self-collision avoidance (original logic used 6) // Also skip if the segment belongs to the attacker itself if (idx < 6) return; // Check distance between attacker's head and victim's segment const victimRad = segRadius(victim.length); // Calculate victim radius if (distTorus(head, seg, _worldW, _worldH) < atkRad + victimRad) { // Use distTorus and sum of radii // Determine outcome based on attacker/victim types if (attacker.isPlayer) { // Player head hits AI body -> Player dies killCb(attacker); } else if (victim.isPlayer) { // AI head hits Player body -> AI dies, Player absorbs killCb(attacker); absorbCb(victim, attacker); } else { // AI head hits other AI body -> Attacker AI dies, Victim AI absorbs killCb(attacker); absorbCb(victim, attacker); } // Important: Exit inner loops once a collision is resolved for this attacker // to prevent multiple collision events from a single impact. // However, the current structure doesn't easily allow breaking outer loops. // Consider refactoring if multiple collisions per frame become an issue. // For now, we assume one collision check per segment is sufficient. // A simple return here only exits the forEach for segments. return; // Exit segment loop for this victim once hit } }); // If attacker died during the inner loop, stop checking further victims for this attacker if (!attacker.visible) return; }); }); // Add head-on collision checks (optional but good) snakes.forEach((s1, i) => { if (!s1.visible) return; const head1 = s1.segs[0]; const rad1 = segRadius(s1.length); for (let j = i + 1; j < snakes.length; j++) { const s2 = snakes[j]; if (!s2.visible) continue; const head2 = s2.segs[0]; const rad2 = segRadius(s2.length); if (dist(head1, head2) < rad1 + rad2) { // Head-on collision: Determine outcome (e.g., both die, longer one wins, etc.) // Simple approach: both die unless one is much larger // const lengthDiff = Math.abs(s1.length - s2.length); // Removed unused variable if (s1.length > s2.length + 5) { // s1 significantly longer killCb(s2); absorbCb(s1, s2); } else if (s2.length > s1.length + 5) { // s2 significantly longer killCb(s1); absorbCb(s2, s1); } else { // Similar length or exact tie: both die killCb(s1); killCb(s2); } } } }); }
```

# src/constants.ts

```ts
// Gameplay settings export const PLAYER_SPEED = 2.5; // Base speed export const PLAYER_TURN_RATE = 0.05; // Radians per frame export const SEGMENT_SPACING = 8; // Distance between segments export const INITIAL_PLAYER_LENGTH = 10; // Starting number of segments export const ORB_DENSITY = 50 / (1000 * 1000); // Orbs per square pixel export const ORB_RADIUS = 10; export const WORLD_PADDING = 50; // Padding from the effective screen edge // Rendering settings export const SEGMENT_RADIUS = 5; export const HEAD_RADIUS = 8; export const EYE_RADIUS = 2; export const EYE_OFFSET = 5; // Distance from head center export const BODY_COLOR = 0x00ff00; // Green export const HEAD_COLOR = 0x00dd00; // Slightly darker green export const EYE_COLOR = 0xffffff; // White export const BORDER_COLOR = 0xffffff; // White border export const BORDER_WIDTH = 2; export const BACKGROUND_VIDEO_PATH = '/cave_city_h264_compat.mp4'; // Or '/cave_city.mp4' // Collision settings export const SELF_COLLISION_THRESHOLD = 5; // Min segments away to trigger collision // UI settings export const SCORE_TEXT_STYLE = { fontFamily: 'Arial', fontSize: 24, fill: 0xffffff, // White align: 'right' as const, };
```

# src/EntityManager.ts

```ts
import AISerpent from './AISerpent'; import PlayerSerpent from './PlayerSerpent'; import Orb from './Orb'; import { AI_COUNT } from './aiConstants'; import * as PIXI from 'pixi.js'; import { SnakeState } from './types'; // Import SnakeState for type safety export default class EntityManager { player!: PlayerSerpent; readonly ai: AISerpent[] = []; readonly orbs: Orb[] = []; private stage: PIXI.Container; constructor(stage: PIXI.Container) { this.stage = stage; } spawnPlayer(): void { this.player = new PlayerSerpent(0,0); this.player.initPixi(this.stage); } spawnAI(worldW:number, worldH:number): void { for(let i=0;i<AI_COUNT;i++){ const x = (Math.random()-0.5)*worldW; const y = (Math.random()-0.5)*worldH; // Generate distinct hues, avoiding pure red (0xFF0000) if possible // Cycle through hues, ensuring some separation const hueStep = 0xFFFFFF / (AI_COUNT + 1); // Divide color space const hue = (i + 1) * hueStep; // Start offset from 0 const s = new AISerpent(x,y, hue); s.initPixi(this.stage); this.ai.push(s); } } // Method to spawn a single AI serpent spawnSingleAI(worldW: number, worldH: number): void { // Check if we are already at or above the limit if (this.ai.length >= AI_COUNT) { console.log("AI count limit reached, not spawning new AI."); return; } const x = (Math.random() - 0.5) * worldW; const y = (Math.random() - 0.5) * worldH; // Simple random hue for respawned AI for now const hue = Math.random() * 0xFFFFFF; const s = new AISerpent(x, y, hue); s.initPixi(this.stage); this.ai.push(s); console.log(`Spawned single AI: ${s.id} at (${x.toFixed(0)}, ${y.toFixed(0)}). Total AI: ${this.ai.length}`); } /* expose flat list for collision queries */ // Ensure the returned array elements conform to SnakeState getAllSnakes(): SnakeState[] { // Explicitly cast PlayerSerpent and AISerpent[] to SnakeState[] // This assumes both classes correctly implement the SnakeState interface return [this.player as unknown as SnakeState, ...this.ai as unknown as SnakeState[]]; } // Method to remove a specific AI serpent removeAISerpent(serpentToRemove: AISerpent): void { const index = this.ai.indexOf(serpentToRemove); if (index > -1) { this.ai.splice(index, 1); } } // Method to remove a specific Orb removeOrb(orbToRemove: Orb): void { const index = this.orbs.indexOf(orbToRemove); if (index > -1) { this.orbs.splice(index, 1); } } }
```

# src/Game.ts

```ts
import * as PIXI from 'pixi.js'; // import Renderer from './Renderer'; // Removed import InputHandler from './InputHandler'; import { UIManager, UIAction } from './UI'; // import PlayerSerpent from './PlayerSerpent'; // Removed unused import // import AISerpent from './AISerpent'; // Removed unused import import Orb from './Orb'; // Added import for generateOrbs import EntityManager from './EntityManager'; // Added import { resolveCollisions } from './CollisionSystem'; // Added import { dist } from './utils'; // Import distance function for overlap check import { // Import types from types.ts KEYBOARD_TURN_COOLDOWN_MS, JOYSTICK_TURN_COOLDOWN_MS, segRadius, OrbTier, ORB_TIER_CONFIG, ORB_TOTAL_SPAWN_WEIGHT, PLAYER_INITIAL_LENGTH, // Import initial length for orb sizing ORB_BASE_RADIUS, // Import new orb sizing constants ORB_RADIUS_MULTIPLIER, SnakeState // Added missing import } from './types'; import { // Import constants from constants.ts ORB_DENSITY, // ORB_RADIUS as CONST_ORB_RADIUS, // No longer needed, calculated dynamically WORLD_PADDING } from './constants'; // Removed unused import: import { AI_COUNT } from './aiConstants'; // --- Constants for Orb Generation (Placeholders - some moved/replaced) --- // ORB_COUNT is now dynamic // ORB_RADIUS is now calculated based on initial player segment size const CLUSTER_PROBABILITY = 0.3; // Increased chance for clusters const MIN_CLUSTER_SIZE = 4; const MAX_CLUSTER_SIZE = 7; const CLUSTER_RADIUS = 50; // Radius for random clusters // CLUSTER_LINE_SPACING is now calculated dynamically based on orbR // Define Game States export enum GameState { LOADING, // Initial state before assets are ready MENU, // Main menu is visible PLAYING, // Game is active PAUSED, // Pause menu is visible CONTROLS,// Controls menu is visible (can overlay Pause or Main) GAME_OVER // Game over screen is visible } class Game { // private renderer: Renderer; // Removed private pixiApp: PIXI.Application; // Added private pixiStage: PIXI.Container; // Added: Reference to the main stage private gameContainer: PIXI.Container; // Added: Container for game world objects (player, orbs, AI) private inputHandler: InputHandler; private uiManager: UIManager; private backgroundVideoElement: HTMLVideoElement; // Store the video element private gameState: GameState = GameState.LOADING; private previousState: GameState = GameState.LOADING; // private playerSerpent: PlayerSerpent | null = null; // Replaced by entities.player // private orbs: Orb[] = []; // Replaced by entities.orbs private entities!: EntityManager; // Added EntityManager private cameraX: number = 0; // Camera position X (relative to world origin) private cameraY: number = 0; // Camera position Y (relative to world origin) private parallaxFactor: number = 0.1; // Game specific state /* no stand-alone score field needed */ private scoreText: PIXI.Text | null = null; // Added for score display private devInfoText: PIXI.Text | null = null; // Added for dev mode display private devModeActive: boolean = false; // Flag for dev mode private borderGraphics: PIXI.Graphics | null = null; // Added for world border private worldWidth: number = 1000; // Default, will be updated private worldHeight: number = 1000; // Default, will be updated private lastMiniBoardUpdate:number = 0; constructor(pixiApp: PIXI.Application, inputHandler: InputHandler, backgroundVideo: HTMLVideoElement) { console.log('Game constructor called'); this.pixiApp = pixiApp; // Store Pixi Application this.pixiStage = pixiApp.stage; // Store Pixi Stage this.inputHandler = inputHandler; this.backgroundVideoElement = backgroundVideo; this.uiManager = new UIManager(this.handleUIAction.bind(this)); // Create the main container for game objects this.gameContainer = new PIXI.Container(); this.pixiStage.addChild(this.gameContainer); // Initial world size calculation this.updateWorldSize(); } // Calculate dynamic world size based on video dimensions, zoom factor, and padding private updateWorldSize(): void { // Base size on video's intrinsic dimensions, fallback if not loaded const baseW = this.backgroundVideoElement.videoWidth || 3840; const baseH = this.backgroundVideoElement.videoHeight || 2160; // Use zoom factor 1.5 ONLY when playing, otherwise use 1.0 for calculations const zoom = this.gameState === GameState.PLAYING ? 1.5 : 1.0; // Effective size of the video content area after zoom const effectiveW = baseW * zoom; const effectiveH = baseH * zoom; // World size is the effective video area minus padding on each side this.worldWidth = effectiveW - WORLD_PADDING * 2; this.worldHeight = effectiveH - WORLD_PADDING * 2; // Ensure world size is not negative if padding is too large for video size/zoom this.worldWidth = Math.max(100, this.worldWidth); // Set a minimum world size this.worldHeight = Math.max(100, this.worldHeight); console.log(`Updated world size: ${this.worldWidth.toFixed(0)}x${this.worldHeight.toFixed(0)} (Video: ${baseW}x${baseH}, Zoom: ${zoom}, Padding: ${WORLD_PADDING})`); // Update border graphics if they exist if (this.borderGraphics) { this.borderGraphics.clear(); this.borderGraphics.rect(-this.worldWidth / 2, -this.worldHeight / 2, this.worldWidth, this.worldHeight); this.borderGraphics.stroke({ width: 5, color: 0xFFFFFF, alpha: 0.3 }); } } init(): void { console.log('Game init called'); this.uiManager.init(); // Initialize Dev Info Text (always add to stage, visibility controlled later) this.devInfoText = new PIXI.Text({ text: '', // Start empty style: { fontFamily: '"Courier New", Courier, monospace', fontSize: 14, fill: 0x00ff00, // Neon green align: 'left', wordWrap: true, // Enable word wrap wordWrapWidth: this.pixiApp.screen.width - 20, // Wrap near screen edge lineHeight: 18, stroke: { color: 0x000000, width: 2, join: 'round' }, // Black stroke for readability } }); this.devInfoText.position.set(10, 30); // Position below FPS counter this.devInfoText.visible = false; // Start hidden this.pixiStage.addChild(this.devInfoText); this.changeState(GameState.MENU); console.log('Game initialized, showing main menu.'); } // Central handler for actions triggered by UI buttons private handleUIAction(action: UIAction): void { console.log(`UI Action received: ${action}`); switch (action) { case 'startGame': this.startGame(); break; case 'showControls': this.showControls(); break; case 'hideControls': this.hideControls(); break; case 'resumeGame': this.resumeGame(); break; case 'newGameFromPause': case 'newGameFromGameOver': this.returnToMenu(); break; // case 'showScoreboard': // Placeholder for original scoreboard button if needed // console.log('Show scoreboard action'); // break; case 'toggleDevMode': this.toggleDevMode(); break; } } // Method to change game state and update UI accordingly private changeState(newState: GameState): void { if (this.gameState === newState) return; if (newState !== GameState.CONTROLS) { this.previousState = this.gameState; } console.log(`Changing state from ${GameState[this.gameState]} to ${GameState[newState]}`); this.gameState = newState; // Update UI and video zoom switch (this.gameState) { case GameState.MENU: this.uiManager.hideAllMenus(); this.uiManager.showMainMenu(); this.setVideoZoom(false); this.gameContainer.visible = false; // Hide game objects in menu break; case GameState.PLAYING: this.uiManager.hideAllMenus(); this.setVideoZoom(true); this.gameContainer.visible = true; // Show game objects if (this.scoreText) this.scoreText.visible = true; // Show score text break; case GameState.PAUSED: this.uiManager.hideAllMenus(); this.uiManager.showPauseMenu(); // Will be updated to pass scores this.setVideoZoom(false); this.gameContainer.visible = true; // Keep game objects visible but static break; case GameState.CONTROLS: // Visibility handled by showControls/hideControls this.setVideoZoom(false); // Keep gameContainer visibility as it was (usually true if paused, false if menu) this.gameContainer.visible = (this.previousState === GameState.PAUSED); break; case GameState.GAME_OVER: this.uiManager.hideAllMenus(); // Use player's score for game over screen this.uiManager.showGameOverMenu(this.entities?.player?.score ?? 0); // Use optional chaining and nullish coalescing this.setVideoZoom(false); this.gameContainer.visible = true; // Show final state if (this.scoreText) this.scoreText.visible = false; // Hide score text break; } // Hide score text in non-playing states by default if (this.gameState !== GameState.PLAYING && this.scoreText) { this.scoreText.visible = false; } } // Helper method to control video zoom (targets the wrapper) and lock transition private setVideoZoom(zoomIn: boolean): void { const scale = zoomIn ? 1.5 : 1; const wrap = document.getElementById('backgroundWrap'); if (wrap) { // Ensure transition is enabled before changing transform wrap.style.transition = 'transform .5s ease'; wrap.style.transform = `scale(${scale})`; console.log(`Setting #backgroundWrap zoom to scale(${scale}) with transition`); // Function to lock the transition after it ends const lockTransition = () => { wrap.style.transition = 'none'; // Disable transition after animation wrap.removeEventListener('transitionend', lockTransition); // Clean up listener console.log("Background zoom transition locked."); }; // Remove any existing listener before adding a new one wrap.removeEventListener('transitionend', lockTransition); // Add listener to lock transition after it completes wrap.addEventListener('transitionend', lockTransition); } else { console.error("Could not find #backgroundWrap element to apply zoom."); } } // --- Game State Control Methods --- startGame(): void { if (this.gameState === GameState.MENU || this.gameState === GameState.GAME_OVER) { this.cleanupGameEntities(); // Clean up previous game objects /* reset via snake */ // Create entities using EntityManager this.entities = new EntityManager(this.gameContainer); this.entities.spawnPlayer(); // Generate orbs and add them to the manager const generatedOrbs = this.generateOrbs(); // Generate first this.entities.orbs.push(...generatedOrbs); // Then add to manager this.entities.orbs.forEach(o => o.initPixi(this.gameContainer)); // Init Pixi for orbs // Change state to PLAYING *before* calculating world size and spawning AI this.changeState(GameState.PLAYING); // Initialize World Border Graphics (now uses PLAYING state zoom) this.updateWorldSize(); // Ensure world size is calculated *after* state change if (!this.borderGraphics) { this.borderGraphics = new PIXI.Graphics(); // Draw initial border (updateWorldSize will redraw if needed) this.borderGraphics.rect(-this.worldWidth / 2, -this.worldHeight / 2, this.worldWidth, this.worldHeight); this.borderGraphics.stroke({ width: 5, color: 0xFFFFFF, alpha: 0.3 }); this.gameContainer.addChild(this.borderGraphics); } else { // Ensure border is redrawn with correct size if restarting game this.borderGraphics.clear(); this.borderGraphics.rect(-this.worldWidth / 2, -this.worldHeight / 2, this.worldWidth, this.worldHeight); this.borderGraphics.stroke({ width: 5, color: 0xFFFFFF, alpha: 0.3 }); } // Reset camera this.cameraX = 0; this.cameraY = 0; this.updateGameContainerPosition(); // Apply initial camera position // Initialize Score Text if (!this.scoreText) { this.scoreText = new PIXI.Text({ text: `Score: ${this.entities.player.score}`, style: { fontFamily: '"Courier New", Courier, monospace', fontSize: 24, fill: 0xffffff, // White align: 'right', stroke: { color: 0x000000, width: 4, join: 'round' }, // Black stroke dropShadow: { color: '#000000', blur: 4, angle: Math.PI / 6, distance: 3 }, } }); this.scoreText.anchor.set(1, 0); // Anchor top-right this.scoreText.position.set(this.pixiApp.screen.width - 10, 10); // Position top-right this.pixiStage.addChild(this.scoreText); // Add to main stage } else { this.scoreText.text = `Score: ${this.entities.player.score}`; // Reset text this.scoreText.visible = true; // Ensure visible } // Spawn AI *after* world size is updated based on PLAYING state zoom this.updateWorldSize(); // Ensure world size is calculated *after* state change this.entities.spawnAI(this.worldWidth, this.worldHeight); // Spawn AI // Log after all spawns console.log(`Starting new game... Player spawned, ${this.entities.orbs.length} orbs generated, ${this.entities.ai.length} AI spawned.`); // this.changeState(GameState.PLAYING); // Moved earlier } } pauseGame(): void { if (this.gameState === GameState.PLAYING) { // Gather scores before changing state if (this.entities) { const currentScores = this.entities.getAllSnakes() .filter(s => s.visible) // Only include visible snakes .map(s => ({ name: s.name, score: s.score, isPlayer: s.isPlayer })); this.uiManager.updatePauseLeaderboard(currentScores); } else { this.uiManager.updatePauseLeaderboard([]); // Show empty if no entities } this.changeState(GameState.PAUSED); } } resumeGame(): void { if (this.gameState === GameState.PAUSED || this.gameState === GameState.CONTROLS) { this.uiManager.hideControlsMenu(); // Ensure controls are hidden if resuming from there this.changeState(GameState.PLAYING); } } showControls(): void { if (this.gameState === GameState.MENU || this.gameState === GameState.PAUSED) { this.previousState = this.gameState; this.uiManager.hideAllMenus(); this.uiManager.showControlsMenu(); this.changeState(GameState.CONTROLS); } } hideControls(): void { if (this.gameState === GameState.CONTROLS) { this.uiManager.hideControlsMenu(); // Restore the previous menu/state if (this.previousState === GameState.MENU) { this.changeState(GameState.MENU); // changeState handles showing the correct menu } else if (this.previousState === GameState.PAUSED) { this.changeState(GameState.PAUSED); // changeState handles showing the correct menu } else { this.changeState(GameState.MENU); // Fallback } } } gameOver(): void { if (this.gameState === GameState.PLAYING) { console.log("Game Over!"); this.changeState(GameState.GAME_OVER); // Entities remain visible but game loop stops updating them } } returnToMenu(): void { this.cleanupGameEntities(); // Clean up before returning to menu this.changeState(GameState.MENU); } // Helper to remove all game entities and their Pixi objects private cleanupGameEntities(): void { console.log("Cleaning up game entities..."); if (this.entities) { if (this.entities.player) { this.entities.player.destroyPixi(); // No need to null player, EntityManager will be replaced } this.entities.orbs.forEach(orb => orb.destroyPixi()); this.entities.ai.forEach(s => s.destroyPixi()); // Clear arrays within the existing manager instance before potentially replacing it this.entities.orbs.length = 0; this.entities.ai.length = 0; // No need to set this.entities = null, it gets overwritten in startGame } // Clean up score text if (this.scoreText) { this.scoreText.destroy(); this.scoreText = null; } // Clean up border graphics if (this.borderGraphics) { this.borderGraphics.destroy(); this.borderGraphics = null; } // Clear the container explicitly (might be redundant if destroyPixi removes children) // Note: destroyPixi in PlayerSerpent/Orb should handle removing children, but this is safer. this.gameContainer.removeChildren(); } // --- Orb Generation --- // Helper function for weighted random tier selection private getRandomOrbTier(): OrbTier { let randomWeight = Math.random() * ORB_TOTAL_SPAWN_WEIGHT; for (const tierStr in ORB_TIER_CONFIG) { const tier = parseInt(tierStr) as OrbTier; // Convert string key back to enum number const config = ORB_TIER_CONFIG[tier]; if (randomWeight < config.spawnWeight) { return tier; } randomWeight -= config.spawnWeight; } return OrbTier.LOW; // Fallback to LOW tier } // Generates orbs based on world size and density constant, attempting to avoid overlaps private generateOrbs(): Orb[] { const generatedOrbs: Orb[] = []; const maxPlacementAttempts = 10; // Max tries to place an orb without overlap // Calculate dynamic orb count based on density const orbCount = Math.round(this.worldWidth * this.worldHeight * ORB_DENSITY); console.log(`Generating approximately ${orbCount} orbs (with overlap avoidance) for world size ${this.worldWidth.toFixed(0)}x${this.worldHeight.toFixed(0)}`); // Use dynamic world size for orb generation bounds const halfWidth = this.worldWidth / 2; const halfHeight = this.worldHeight / 2; // Helper to check for overlap - checks center distance against combined radii const isOverlapping = (x: number, y: number, radius: number, existingOrbs: Orb[]): boolean => { for (const existing of existingOrbs) { // Use sum of radii for check to ensure visual separation if (dist({ x, y }, existing) < radius + existing.radius) { return true; } } return false; }; // Calculate the desired orb radius once const baseSegR = segRadius(PLAYER_INITIAL_LENGTH); const orbR = Math.max(ORB_BASE_RADIUS, baseSegR * ORB_RADIUS_MULTIPLIER); const adjustedLineSpacing = orbR * 2.5; // Spacing for line clusters based on new radius let orbsAttempted = 0; // Track attempts to prevent infinite loops in edge cases const maxTotalAttempts = orbCount * maxPlacementAttempts * 2; // Safety break while (generatedOrbs.length < orbCount && orbsAttempted < maxTotalAttempts) { orbsAttempted++; // Decide whether to generate a cluster or single orb const isCluster = Math.random() < CLUSTER_PROBABILITY && (orbCount - generatedOrbs.length) >= MIN_CLUSTER_SIZE; if (isCluster) { const clusterSize = Math.floor(Math.random() * (MAX_CLUSTER_SIZE - MIN_CLUSTER_SIZE + 1)) + MIN_CLUSTER_SIZE; let clusterOrbsPlaced = 0; // Try finding a center for the cluster first (fewer attempts needed here) let clusterCenterX = 0; let clusterCenterY = 0; let centerFound = false; for (let attempt = 0; attempt < maxPlacementAttempts; attempt++) { clusterCenterX = Math.random() * this.worldWidth - halfWidth; clusterCenterY = Math.random() * this.worldHeight - halfHeight; // Check if center itself is clear enough (using orbR as a proxy) if (!isOverlapping(clusterCenterX, clusterCenterY, orbR, generatedOrbs)) { centerFound = true; break; } } if (!centerFound) continue; // Skip this cluster attempt if center is too crowded const isLineCluster = Math.random() < 0.5; if (isLineCluster) { const lineAngle = Math.random() * Math.PI * 2; const dx = Math.cos(lineAngle) * adjustedLineSpacing; // Use adjusted spacing const dy = Math.sin(lineAngle) * adjustedLineSpacing; let currentX = clusterCenterX - (dx * (clusterSize - 1)) / 2; let currentY = clusterCenterY - (dy * (clusterSize - 1)) / 2; for (let i = 0; i < clusterSize && generatedOrbs.length < orbCount; i++) { // Check overlap for the specific position in the line if (!isOverlapping(currentX, currentY, orbR, generatedOrbs)) { const tier = this.getRandomOrbTier(); generatedOrbs.push(new Orb(currentX, currentY, orbR, tier)); clusterOrbsPlaced++; } else { // Optional: Could try slightly nudging position, but skipping is simpler // console.log("Skipping line cluster orb due to overlap."); } currentX += dx; currentY += dy; } } else { // Scatter Cluster for (let i = 0; i < clusterSize && generatedOrbs.length < orbCount; i++) { let orbX = 0, orbY = 0; let positionFound = false; for (let attempt = 0; attempt < maxPlacementAttempts; attempt++) { const angle = Math.random() * Math.PI * 2; const radiusOffset = Math.random() * CLUSTER_RADIUS; // Keep original cluster radius orbX = clusterCenterX + Math.cos(angle) * radiusOffset; orbY = clusterCenterY + Math.sin(angle) * radiusOffset; if (!isOverlapping(orbX, orbY, orbR, generatedOrbs)) { positionFound = true; break; } } if (positionFound) { const tier = this.getRandomOrbTier(); generatedOrbs.push(new Orb(orbX, orbY, orbR, tier)); clusterOrbsPlaced++; } else { // console.log("Skipping scatter cluster orb due to overlap after attempts."); } } } // console.log(`Cluster attempt: Placed ${clusterOrbsPlaced}/${clusterSize} orbs.`); } else { // Single Orb let orbX = 0, orbY = 0; let positionFound = false; for (let attempt = 0; attempt < maxPlacementAttempts; attempt++) { orbX = Math.random() * this.worldWidth - halfWidth; orbY = Math.random() * this.worldHeight - halfHeight; if (!isOverlapping(orbX, orbY, orbR, generatedOrbs)) { positionFound = true; break; } } if (positionFound) { const tier = this.getRandomOrbTier(); generatedOrbs.push(new Orb(orbX, orbY, orbR, tier)); } else { // console.log("Skipping single orb due to overlap after attempts."); } } // The main while loop condition (generatedOrbs.length < orbCount) handles stopping. } if (orbsAttempted >= maxTotalAttempts && generatedOrbs.length < orbCount) { console.warn(`Orb generation stopped early after ${maxTotalAttempts} attempts to avoid potential infinite loop. Generated ${generatedOrbs.length}/${orbCount} orbs.`); } else { console.log(`Successfully generated ${generatedOrbs.length} orbs.`); } return generatedOrbs; } // --- Core Game Loop Methods --- update(deltaTime: number): void { // Game logic update only happens when PLAYING if (this.gameState !== GameState.PLAYING || !this.entities) { // Ensure entities exist return; } // Get entities for easier access const { player, ai, orbs } = this.entities; const now = performance.now(); // Get current time once // --- Player Input & Physics --- // Extracted logic for getting desired direction (can be refactored later) let desiredDir = this.inputHandler.getJoystickDirection(); let turnCooldown = JOYSTICK_TURN_COOLDOWN_MS; let isJoystickActive = desiredDir.x !== 0 || desiredDir.y !== 0; if (!isJoystickActive) { const keyboardDir = this.inputHandler.getKeyboardDirection(); if (keyboardDir.x !== 0 || keyboardDir.y !== 0) { const magnitude = Math.hypot(keyboardDir.x, keyboardDir.y); desiredDir = { x: keyboardDir.x / magnitude, y: keyboardDir.y / magnitude }; turnCooldown = KEYBOARD_TURN_COOLDOWN_MS; } else { desiredDir = { x: 0, y: 0 }; // No input } } // Apply turn if there's input if (desiredDir.x !== 0 || desiredDir.y !== 0) { player.attemptTurn(desiredDir, now, turnCooldown); } // Update player physics player.update(deltaTime, this.worldWidth, this.worldHeight); // Update camera to follow player this.cameraX = player.segs[0].x; this.cameraY = player.segs[0].y; // Update parallax and container position based on camera this.updateBackgroundParallax(); this.updateGameContainerPosition(); // Sync player graphics player.syncPixi(player.calculateSkipSegments(), this.worldWidth, this.worldHeight); // --- AI Update & Sync --- ai.forEach(s => { if (!s.visible) return; // Skip dead AI s.updateAI(deltaTime, now, orbs, this.entities.getAllSnakes(), this.worldWidth, this.worldHeight); s.syncPixi(s.calculateSkipSegments(), this.worldWidth, this.worldHeight); }); // ---- AI eats orbs ---- // Added block ai.forEach(bot=>{ if (!bot.visible) return; // Skip dead bots const head = bot.segs[0]; const botRad = segRadius(bot.length); for(let k=orbs.length-1;k>=0;k--){ // Iterate backwards for safe removal const orb=orbs[k]; if(!orb.visible) continue; if(dist(head,orb) < botRad + orb.radius){ bot.eatOrb(orb.value); // AI eats orb orb.visible=false; orb.destroyPixi(); this.entities.removeOrb(orb); // Remove from manager } } }); // --- Orb Sync --- (Update logic removed as they are static for now) orbs.forEach(o => o.syncPixi()); // Sync remaining orbs // --- Collisions --- resolveCollisions(this.entities, this.worldWidth, this.worldHeight, (snake) => this.killSnake(snake), // Pass kill callback (winner, loser) => this.absorb(winner, loser)); // Pass absorb callback // --- Check Orb Collisions (Player Head vs Orbs) --- this.checkOrbCollisions(); // Separate check for player eating orbs // --- Update Score Text --- if (this.scoreText) { this.scoreText.text = `Score: ${this.entities.player.score}`; } // --- Mini-leaderboard (update each ½ sec) --- if (now - (this.lastMiniBoardUpdate ?? 0) > 500) { this.lastMiniBoardUpdate = now; const scores = this.entities.getAllSnakes() .filter(s => s.visible) .map(s => ({ name: s.name, score: s.score, isPlayer: s.isPlayer })); this.uiManager.updateMiniLeaderboard(scores); } // --- Update Dev Info Display --- // Ensure player exists before accessing properties for dev info if (this.devModeActive && this.devInfoText && player) { this.updateDevInfoText(); this.devInfoText.visible = true; } else if (this.devInfoText) { this.devInfoText.visible = false; } // Example: Check for game over condition // if (some_condition) { // this.gameOver(); // } } // render(deltaTime: number): void { // REMOVED - PixiJS handles rendering via ticker // } // --- Collision Detection --- (REMOVED - Handled by resolveCollisions and checkOrbCollisions) // private checkCollisions(): void { ... } // --- Orb Collision Check (Player only) --- private checkOrbCollisions(): void { if (!this.entities || !this.entities.player || !this.entities.player.visible) return; const player = this.entities.player; const head = player.segs[0]; const playerRadius = segRadius(player.length); // Iterate backwards to safely remove orbs while looping for (let i = this.entities.orbs.length - 1; i >= 0; i--) { const orb = this.entities.orbs[i]; if (!orb.visible) continue; // Skip already invisible orbs const distance = dist(head, orb); const collisionThreshold = playerRadius + orb.radius; if (distance < collisionThreshold) { // Collision detected! console.log("Player ate orb!"); player.score += orb.value; // keep truth in one place player.eatOrb(orb.value); // Trigger eating effects on player // Mark orb for removal, destroy its Pixi object, and remove from manager orb.visible = false; orb.destroyPixi(); this.entities.removeOrb(orb); // Use EntityManager method } } // Self-collision check (moved from old checkCollisions) const skipCount = player.calculateSkipSegments(); if (player.willHitTail(head.x, head.y, skipCount)) { this.killSnake(player); // Use killSnake for consistency } } // --- Camera Simulation --- private updateGameContainerPosition(): void { // To simulate the camera, we move the game container *opposite* to the camera's logical position. // The container's top-left corner should be positioned such that the camera's logical center // aligns with the screen's center. const screenWidth = this.pixiApp.screen.width; const screenHeight = this.pixiApp.screen.height; // Calculate the desired top-left position of the container const containerX = screenWidth / 2 - this.cameraX; const containerY = screenHeight / 2 - this.cameraY; this.gameContainer.position.set(containerX, containerY); } resize(width: number, height: number): void { console.log('Game resize called with dimensions:', width, height); // Recalculate world size based on new screen dimensions this.updateWorldSize(); // Re-center the game container based on the new screen size this.updateGameContainerPosition(); // Reposition score text and dev info text on resize if (this.scoreText) { this.scoreText.position.set(width - 10, 10); } if (this.devInfoText) { this.devInfoText.position.set(10, 30); // Keep below FPS // Adjust wrap width if needed if (this.devInfoText.style.wordWrapWidth !== width - 20) { this.devInfoText.style.wordWrapWidth = width - 20; } } } // Pause/Resume called by main.ts on visibility change pause(): void { console.log('Game focus lost (pause)'); if (this.gameState === GameState.PLAYING) { this.pauseGame(); // Automatically pause if tab loses focus while playing } } resume(): void { console.log('Game focus gained (resume)'); // Don't automatically resume gameplay state, let user do it via UI. // Ticker is restarted in main.ts's visibility handler. } // Public getter for the current state public getCurrentState(): GameState { return this.gameState; } // --- Dev Mode --- private toggleDevMode(): void { this.devModeActive = !this.devModeActive; console.log(`Dev Mode ${this.devModeActive ? 'Activated' : 'Deactivated'}`); // Visibility of devInfoText is handled in the update loop } private updateDevInfoText(): void { // Check entities and player exist if (!this.devInfoText || !this.entities || !this.entities.player) { return; } const player = this.entities.player; // Use player from entities // Access player properties (ensure they are public or have getters) const segCount = player.segs.length; const currentSpeed = player.speed.toFixed(1); // Access public properties directly const baseSpeed = player.baseSpeed.toFixed(1); const boostTimer = player.speedBoostTimer.toFixed(2); const logicalLength = player.length.toFixed(0); const headX = player.segs[0].x.toFixed(0); const headY = player.segs[0].y.toFixed(0); const cameraX = this.cameraX.toFixed(0); const cameraY = this.cameraY.toFixed(0); const worldW = this.worldWidth.toFixed(0); const worldH = this.worldHeight.toFixed(0); this.devInfoText.text = `Segments: ${segCount} (Logical: ${logicalLength})\n` + `Speed: ${currentSpeed} (Base: ${baseSpeed})\n` + `Boost Time: ${boostTimer}s\n` + `Head Pos: (${headX}, ${headY})\n` + `Camera: (${cameraX}, ${cameraY})\n` + `World: ${worldW}x${worldH}`; } // --- Parallax Update --- private updateBackgroundParallax(): void { const parallaxX = -this.cameraX * this.parallaxFactor; const parallaxY = -this.cameraY * this.parallaxFactor; const parallaxWrap = document.getElementById('parallaxWrap') as HTMLElement | null; if (parallaxWrap) { // Apply only translation to the parallax wrapper parallaxWrap.style.transform = `translate3d(${parallaxX}px, ${parallaxY}px, 0)`; } else { // console.warn("Could not find #parallaxWrap element for parallax update."); // Keep commented unless debugging } // The video element itself no longer needs per-frame transform updates // this.backgroundVideoElement.style.transform = `...`; // Removed } // --- Collision Resolution Helpers --- Added private killSnake(s: SnakeState): void { // Accept SnakeState if (!s.visible) return; // Already dead console.log(`Killing snake: ${s.id}`); s.visible = false; // Mark state as not visible // Find the actual instance to call destroyPixi on const instanceToDestroy = s.isPlayer ? this.entities.player : this.entities.ai.find(aiSnake => aiSnake.id === s.id); if (instanceToDestroy) { instanceToDestroy.destroyPixi(); // Call destroyPixi on the actual instance } else { console.error(`Could not find instance with ID ${s.id} to destroy Pixi object.`); } if (s.isPlayer) { this.gameOver(); } else { // Remove AI snake from the manager - Need to find the AISerpent instance // Find the corresponding AISerpent instance in the manager's list const aiToRemove = this.entities.ai.find(aiSnake => aiSnake.id === s.id); if (aiToRemove) { this.entities.removeAISerpent(aiToRemove); // ✅ respawn replacement after 3 s setTimeout(()=>{ // Check if entities still exist (game might have ended/restarted) if (this.entities) { console.log(`Respawning AI after snake ${s.id} was killed.`); // Need to call spawnSingleAI on the instance, not the class this.entities.spawnSingleAI(this.worldWidth, this.worldHeight); // Call the new method } }, 3000); } else { console.warn(`Could not find AI serpent with ID ${s.id} to remove.`); } } } private absorb(winnerState: SnakeState, loserState: SnakeState): void { // Accept SnakeState if (!winnerState.visible || !loserState.visible) return; // Ensure both are 'alive' at the moment of absorption // Find the actual winner/loser instances in the entity manager const winner = winnerState.isPlayer ? this.entities.player : this.entities.ai.find(s => s.id === winnerState.id); const loser = loserState.isPlayer ? this.entities.player : this.entities.ai.find(s => s.id === loserState.id); // Ensure both instances were found if (!winner || !loser) { console.error("Could not find winner or loser instance for absorption.", { winnerId: winnerState.id, loserId: loserState.id }); return; } console.log(`Snake ${winner.id} absorbing snake ${loser.id}`); winner.length += loser.length; // Add logical length winner.score += loser.score; // Add score (assuming score property exists or is added) // Append segments (skip neck of loser) // Ensure loser.segs exists and has enough segments if (loser.segs && loser.segs.length > 6) { winner.segs.push(...loser.segs.slice(6)); } // Winner's graphics will update automatically based on new segs array in syncPixi } // --- KeyDown Handler --- Added to satisfy main.ts public handleKeyDown(event: KeyboardEvent): void { // Handle global keys like Pause (Space, Esc) switch (event.key) { case 'Escape': if (this.gameState === GameState.PLAYING) { this.pauseGame(); } else if (this.gameState === GameState.PAUSED) { this.resumeGame(); // Allow Esc to resume from pause } else if (this.gameState === GameState.CONTROLS) { this.hideControls(); // Allow Esc to exit controls } break; case ' ': // Space bar event.preventDefault(); // Prevent page scroll if (this.gameState === GameState.PLAYING) { this.pauseGame(); } else if (this.gameState === GameState.PAUSED) { this.resumeGame(); } else if (this.gameState === GameState.GAME_OVER) { this.returnToMenu(); // Space on game over goes to menu } // No action for space on main menu or controls for now break; } // Note: Movement keys (WASD/Arrows) are handled by InputHandler polling in the update loop } } export default Game;
```

# src/InputHandler.ts

```ts
import { Point } from './types'; import * as PIXI from 'pixi.js'; // Import PixiJS // Define a more detailed JoystickState interface JoystickState { active: boolean; startPosition: Point | null; // Position where touch began currentPosition: Point | null; // Current touch position vector: Point; // Calculated direction vector (normalized) deadzoneRadius: number; // Radius around start where input is ignored maxTravelRadius?: number; // Max distance knob can move from base center } class InputHandler { private canvas: HTMLCanvasElement; // private keys: { [key: string]: boolean }; // Keep generic keys if needed, but use specific flags for movement private joystick: JoystickState; // PixiJS graphics for joystick visualization private joystickContainer: PIXI.Container | null = null; private joystickBaseGraphics: PIXI.Graphics | null = null; private joystickKnobGraphics: PIXI.Graphics | null = null; // Track movement key states private moveUp: boolean = false; private moveDown: boolean = false; private moveLeft: boolean = false; private moveRight: boolean = false; constructor(canvas: HTMLCanvasElement) { console.log('InputHandler constructor called'); this.canvas = canvas; // Store input state this.joystick = { active: false, startPosition: null, currentPosition: null, vector: { x: 0, y: 0 }, deadzoneRadius: 20 // Example deadzone radius in pixels }; // No need for void this.joystick anymore // Add event listeners this.addEventListeners(); // No need for void this.canvas anymore } // --- PixiJS Graphics Methods --- /** Initializes the PixiJS graphics objects for the joystick */ initJoystickGraphics(stage: PIXI.Container): void { this.joystickContainer = new PIXI.Container(); this.joystickContainer.visible = false; // Initially hidden // Define appearance const baseRadius = 50; const knobRadius = 25; const baseColor = 0xcccccc; const knobColor = 0x888888; const baseAlpha = 0.3; const knobAlpha = 0.5; // Create base graphics this.joystickBaseGraphics = new PIXI.Graphics(); this.joystickBaseGraphics.circle(0, 0, baseRadius); this.joystickBaseGraphics.fill({ color: baseColor, alpha: baseAlpha }); this.joystickContainer.addChild(this.joystickBaseGraphics); // Create knob graphics this.joystickKnobGraphics = new PIXI.Graphics(); this.joystickKnobGraphics.circle(0, 0, knobRadius); this.joystickKnobGraphics.fill({ color: knobColor, alpha: knobAlpha }); this.joystickContainer.addChild(this.joystickKnobGraphics); // Add the container to the main stage stage.addChild(this.joystickContainer); // Set max travel radius based on base radius this.joystick.maxTravelRadius = baseRadius - knobRadius / 2; // Knob center shouldn't go past base edge console.log('Joystick graphics initialized.'); } /** Updates the joystick graphics based on the current state */ updateJoystickGraphics(): void { if (!this.joystickContainer || !this.joystickBaseGraphics || !this.joystickKnobGraphics) { return; } this.joystickContainer.visible = this.joystick.active; if (this.joystick.active && this.joystick.startPosition && this.joystick.currentPosition) { // Position the container (base) at the start position this.joystickContainer.position.set(this.joystick.startPosition.x, this.joystick.startPosition.y); // Calculate knob position relative to the base center let knobX = this.joystick.currentPosition.x - this.joystick.startPosition.x; let knobY = this.joystick.currentPosition.y - this.joystick.startPosition.y; const distance = Math.hypot(knobX, knobY); // Clamp knob position within the max travel radius const maxRadius = this.joystick.maxTravelRadius ?? 50; // Use default if not set if (distance > maxRadius) { const scale = maxRadius / distance; knobX *= scale; knobY *= scale; } // Apply deadzone visually (optional, could just snap to center if vector is 0,0) if (this.joystick.vector.x === 0 && this.joystick.vector.y === 0) { knobX = 0; knobY = 0; } this.joystickKnobGraphics.position.set(knobX, knobY); } } /** Cleans up the joystick graphics */ destroyJoystickGraphics(): void { if (this.joystickContainer) { this.joystickContainer.parent?.removeChild(this.joystickContainer); this.joystickContainer.destroy({ children: true }); this.joystickContainer = null; this.joystickBaseGraphics = null; this.joystickKnobGraphics = null; console.log('Joystick graphics destroyed.'); } } // --- Event Listeners --- addEventListeners(): void { console.log('InputHandler adding event listeners'); // Bind listeners correctly to maintain 'this' context this.handleKeyDown = this.handleKeyDown.bind(this); this.handleKeyUp = this.handleKeyUp.bind(this); this.handleTouchStart = this.handleTouchStart.bind(this); this.handleTouchMove = this.handleTouchMove.bind(this); this.handleTouchEnd = this.handleTouchEnd.bind(this); // Add keyboard listeners window.addEventListener('keydown', this.handleKeyDown); window.addEventListener('keyup', this.handleKeyUp); // Add touch listeners to the canvas this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false }); // passive: false to allow preventDefault this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false }); this.canvas.addEventListener('touchend', this.handleTouchEnd); this.canvas.addEventListener('touchcancel', this.handleTouchEnd); // Treat cancel like end } removeEventListeners(): void { console.log('InputHandler removing event listeners'); // Remove keyboard listeners window.removeEventListener('keydown', this.handleKeyDown); window.removeEventListener('keyup', this.handleKeyUp); // Remove touch listeners this.canvas.removeEventListener('touchstart', this.handleTouchStart); this.canvas.removeEventListener('touchmove', this.handleTouchMove); this.canvas.removeEventListener('touchend', this.handleTouchEnd); this.canvas.removeEventListener('touchcancel', this.handleTouchEnd); } // Keyboard event handlers private handleKeyDown(event: KeyboardEvent): void { // Prevent default browser actions for arrow keys, WASD, space if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(event.key)) { // Keep space bar preventDefault in main.ts for game state control if (event.key !== ' ') { event.preventDefault(); } } switch (event.key) { case 'w': case 'ArrowUp': this.moveUp = true; break; case 's': case 'ArrowDown': this.moveDown = true; break; case 'a': case 'ArrowLeft': this.moveLeft = true; break; case 'd': case 'ArrowRight': this.moveRight = true; break; } // Store generic key state if needed elsewhere // this.keys[event.key] = true; } private handleKeyUp(event: KeyboardEvent): void { switch (event.key) { case 'w': case 'ArrowUp': this.moveUp = false; break; case 's': case 'ArrowDown': this.moveDown = false; break; case 'a': case 'ArrowLeft': this.moveLeft = false; break; case 'd': case 'ArrowRight': this.moveRight = false; break; } // Store generic key state if needed elsewhere // delete this.keys[event.key]; } // --- Touch Event Handlers --- private handleTouchStart(event: TouchEvent): void { event.preventDefault(); // Prevent scrolling/zooming if (event.touches.length > 0) { const touch = event.touches[0]; const rect = this.canvas.getBoundingClientRect(); this.joystick.startPosition = { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; this.joystick.currentPosition = { ...this.joystick.startPosition }; // Start at the same point this.joystick.active = true; this.joystick.vector = { x: 0, y: 0 }; // Reset vector initially // console.log('Touch Start:', this.joystick.startPosition); // Update graphics immediately on touch start this.updateJoystickGraphics(); } } private handleTouchMove(event: TouchEvent): void { event.preventDefault(); if (!this.joystick.active || !this.joystick.startPosition || event.touches.length === 0) { return; } const touch = event.touches[0]; const rect = this.canvas.getBoundingClientRect(); this.joystick.currentPosition = { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; // Calculate vector from start to current let dx = this.joystick.currentPosition.x - this.joystick.startPosition.x; let dy = this.joystick.currentPosition.y - this.joystick.startPosition.y; const distance = Math.hypot(dx, dy); // Apply deadzone if (distance < this.joystick.deadzoneRadius) { this.joystick.vector = { x: 0, y: 0 }; } else { // Normalize the vector this.joystick.vector = { x: dx / distance, y: dy / distance }; } // console.log('Touch Move - Vector:', this.joystick.vector); // Update graphics on move this.updateJoystickGraphics(); } private handleTouchEnd(/* event: TouchEvent */): void { // Removed unused event parameter // Check if the touch ending is the one we were tracking (optional but good practice) // For simplicity, we assume any touchend deactivates the joystick if active. if (this.joystick.active) { this.joystick.active = false; this.joystick.startPosition = null; this.joystick.currentPosition = null; // Keep the last vector? Or reset? Let's keep it for now, serpent continues. // this.joystick.vector = { x: 0, y: 0 }; // console.log('Touch End'); // Update graphics (will hide the container) this.updateJoystickGraphics(); } } // Method to get the desired movement direction from keyboard // Returns a non-normalized vector, or {x: 0, y: 0} if no direction keys are pressed getKeyboardDirection(): Point { let dx = 0; let dy = 0; if (this.moveUp) dy -= 1; if (this.moveDown) dy += 1; if (this.moveLeft) dx -= 1; if (this.moveRight) dx += 1; // Combine for diagonal movement. Normalization should happen before use. return { x: dx, y: dy }; } // Method to get the desired movement direction from joystick // Returns a *normalized* vector, or {x: 0, y: 0} if inactive or in deadzone getJoystickDirection(): Point { return this.joystick.active ? this.joystick.vector : { x: 0, y: 0 }; } // Method to get current input state (optional, maybe remove if not needed) // getInputState(): { keys: { [key: string]: boolean }, joystick: JoystickState } { // // Return current state of keys and joystick // return { // keys: this.keys, // joystick: this.joystick // }; // } } export default InputHandler;
```

# src/main.ts

```ts
import * as PIXI from 'pixi.js'; import Game, { GameState } from './Game'; // Import GameState enum import InputHandler from './InputHandler'; let game: Game | undefined; let inputHandler: InputHandler | undefined; let pixiApp: PIXI.Application | undefined; let fpsText: PIXI.Text | undefined; // Added for FPS counter // DOM Element References const pixiContainer = document.getElementById('pixi-container') as HTMLDivElement | null; const backgroundVideo = document.getElementById('backgroundVideo') as HTMLVideoElement | null; const loadingScreen = document.getElementById('loadingScreen') as HTMLDivElement | null; // --- Initialization --- if (!pixiContainer || !backgroundVideo || !loadingScreen) { console.error('Critical DOM elements not found! Need #pixi-container, #backgroundVideo, #loadingScreen.'); if (loadingScreen) { loadingScreen.textContent = 'Error: Missing required page elements. Cannot initialize game.'; } } else { // Add listeners early window.addEventListener('resize', handleResize); document.addEventListener('visibilitychange', handleVisibilityChange); window.addEventListener('keydown', handleKeyDown); // Asynchronous initialization function async function initializeGame(): Promise<void> { try { // 1. Create PixiJS Application pixiApp = new PIXI.Application(); // 2. Initialize PixiJS Application with settings await pixiApp.init({ width: window.innerWidth, height: window.innerHeight, backgroundAlpha: 0, // Transparent background powerPreference: 'high-performance', // Request high performance GPU // gcMode: PIXI.GC_MODE.AUTO, // Removed - Not a valid option in v8 ApplicationOptions antialias: true, resolution: window.devicePixelRatio || 1, // Adjust for device pixel ratio autoDensity: true, // Automatically handle resolution changes }); // 3. Append PixiJS canvas to the container pixiContainer!.appendChild(pixiApp.canvas); // Use non-null assertion // 4. Instantiate Input Handler (pass PixiJS canvas for touch events) inputHandler = new InputHandler(pixiApp.canvas); // Pass PixiJS canvas inputHandler.initJoystickGraphics(pixiApp.stage); // Initialize joystick visuals // Preload orb textures before setting up the game console.log("Loading orb assets..."); await PIXI.Assets.load(['/orb1.png','/orb2.png','/orb3.png']); console.log("Orb assets loaded."); // 5. Wait for video metadata before instantiating Game const setupGame = () => { // Instantiate Game (pass PixiJS App and other dependencies) game = new Game(pixiApp!, inputHandler!, backgroundVideo!); // Use non-null assertions // Initialize game state (creates menus, etc.) game.init(); // Initialize FPS Counter Text fpsText = new PIXI.Text({ text: 'FPS: 0', style: { fontFamily: 'Arial', fontSize: 18, fill: 0x00ff00, // Neon green align: 'left', } }); fpsText.position.set(10, 10); // Position top-left pixiApp!.stage.addChild(fpsText); // Add to the main stage (not gameContainer) // Set up PixiJS Ticker for the game loop pixiApp!.ticker.maxFPS = 60; // Cap FPS pixiApp!.ticker.add((ticker: PIXI.Ticker) => { // Update FPS counter if (fpsText) { fpsText.text = `FPS: ${ticker.FPS.toFixed(2)}`; } // Update game logic if playing if (game && game.getCurrentState() === GameState.PLAYING) { const deltaTimeSeconds = ticker.deltaMS / 1000.0; // Clamp delta time to prevent large jumps (e.g., after tab focus) const clampedDeltaTime = Math.min(deltaTimeSeconds, 1 / 30); // Max ~30 FPS step game.update(clampedDeltaTime); // Rendering is handled by PixiJS automatically based on stage updates in game.update -> entity.syncPixi() } // Update joystick visuals regardless of game state if (inputHandler) { inputHandler.updateJoystickGraphics(); } }); // Ticker starts automatically // Hide loading screen loadingScreen!.style.display = 'none'; // Use non-null assertion // Initial resize call to ensure correct sizing handleResize(); // Ensure background video plays (moved here to ensure it plays after setup) backgroundVideo!.play().catch(error => { console.warn('Background video autoplay prevented:', error); // Consider adding a user interaction requirement to play video }); }; // Check if metadata is already loaded if (backgroundVideo!.readyState >= backgroundVideo!.HAVE_METADATA) { console.log("Video metadata already loaded."); setupGame(); } else { console.log("Waiting for video metadata..."); backgroundVideo!.addEventListener('loadedmetadata', () => { console.log("Video metadata loaded."); setupGame(); }, { once: true }); // Ensure listener runs only once } // --- Ticker and Loading Screen logic moved inside setupGame --- /* // 6.5 Initialize FPS Counter Text fpsText = new PIXI.Text({ text: 'FPS: 0', style: { fontFamily: 'Arial', fontSize: 18, fill: 0x00ff00, // Neon green align: 'left', } }); fpsText.position.set(10, 10); // Position top-left */ } catch (error) { console.error('Game initialization failed:', error); if (loadingScreen) { const message = (error instanceof Error) ? error.message : String(error); loadingScreen.textContent = `Error during initialization: ${message}. Check console.`; loadingScreen.style.color = 'red'; } // Clean up PixiJS app if initialization failed partially if (pixiApp) { inputHandler?.destroyJoystickGraphics(); // Clean up joystick graphics // Remove baseTexture, it's not a valid option here pixiApp.destroy(true, { children: true, texture: true /*, baseTexture: true */ }); pixiApp = undefined; } } } // Start the initialization process initializeGame(); } // --- Event Handlers --- function handleResize(): void { if (pixiApp && game) { const newWidth = window.innerWidth; const newHeight = window.innerHeight; // Resize the PixiJS renderer pixiApp.renderer.resize(newWidth, newHeight); // Optionally notify the game about the resize if it needs to adjust layout game.resize(newWidth, newHeight); } } function handleVisibilityChange(): void { if (!pixiApp || !game) return; if (document.hidden) { // Tab is hidden pixiApp.ticker.stop(); // Stop the PixiJS ticker game.pause(); // Pause game logic (handles state change) console.log("Game paused - Tab hidden"); } else { // Tab is visible pixiApp.ticker.start(); // Start the PixiJS ticker // game.resume(); // Game resume logic should be handled by user interaction (e.g., clicking resume button) console.log("Game active - Tab visible"); // Note: We don't automatically resume the game's *state* here, // only the rendering loop. The game remains paused until the user resumes it via UI. // If the game wasn't paused by the user before hiding, it might need explicit resume. // Let's rely on the game's internal state management triggered by UI. } } function handleKeyDown(event: KeyboardEvent): void { if (!game) return; // Game not initialized yet // const currentState = game.getCurrentState(); // Removed unused variable // Let the game instance handle keydown events for state changes (pause/resume) game.handleKeyDown(event); // Example of direct handling (could be moved into Game class): // switch (event.key) { // case 'Escape': // if (currentState === GameState.PLAYING) { // game.pauseGame(); // } else if (currentState === GameState.PAUSED) { // game.resumeGame(); // } else if (currentState === GameState.CONTROLS) { // game.hideControls(); // } // break; // case ' ': // Space bar // event.preventDefault(); // Prevent page scroll // if (currentState === GameState.PLAYING) { // game.pauseGame(); // } else if (currentState === GameState.PAUSED) { // game.resumeGame(); // } else if (currentState === GameState.GAME_OVER) { // game.returnToMenu(); // } // break; // } }
```

# src/Orb.ts

```ts
import * as PIXI from 'pixi.js'; // Import PixiJS import { OrbTier, ORB_TIER_CONFIG, ORB_TEXTURE } from './types'; // Import Orb tier types and texture map // Represents a collectible orb export class Orb { public x: number; public y: number; public radius: number; // Represents the collision radius (circle inside sprite) public tier: OrbTier; // Store the tier public value: number; // Value derived from tier public visible: boolean = true; // Added visibility state // --- PixiJS Integration --- public pixiSprite: PIXI.Sprite | null = null; // Changed from pixiObject (Graphics) to pixiSprite constructor(x: number, y: number, radius: number, tier: OrbTier) { this.x = x; this.y = y; this.radius = radius; this.tier = tier; this.value = ORB_TIER_CONFIG[tier].value; // Get value from config // Removed console log for brevity during generation } // --- PixiJS Methods --- /** Initializes the PixiJS Sprite object for the orb */ initPixi(stage: PIXI.Container): void { if (this.pixiSprite) { this.destroyPixi(); // Clean up existing sprite if any } // Get texture from the preloaded assets based on tier const texturePath = ORB_TEXTURE[this.tier]; const texture = PIXI.Assets.get(texturePath); // Use PIXI.Assets.get if (!texture) { console.error(`Orb texture not found: ${texturePath}`); return; // Cannot create sprite without texture } // Set scale mode for crisp pixels (optional polish) texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST; this.pixiSprite = new PIXI.Sprite(texture); this.pixiSprite.anchor.set(0.5); // Center the anchor // Set initial size based on the provided radius (diameter = radius * 2) // This radius comes from generateOrbs and is calculated using ORB_BASE_RADIUS/ORB_RADIUS_MULTIPLIER this.pixiSprite.width = this.radius * 2; this.pixiSprite.height = this.radius * 2; // Set initial position and visibility this.pixiSprite.position.set(this.x, this.y); this.pixiSprite.visible = this.visible; // Add to the stage stage.addChild(this.pixiSprite); } /** Updates the PixiJS Sprite object to match the orb's current state */ syncPixi(): void { if (!this.pixiSprite) return; // Update visibility first this.pixiSprite.visible = this.visible; if (this.visible) { // Update position if visible this.pixiSprite.position.set(this.x, this.y); // Update size if needed (e.g., if player segment size changes dynamically) // For now, size is set at init based on initial player segment size. // If we want dynamic orb size matching player size, we'd need to pass // the current player segment radius here and update width/height. // this.pixiSprite.width = currentSegmentRadius * 2; // this.pixiSprite.height = currentSegmentRadius * 2; } } /** Removes the PixiJS Sprite object from the stage and destroys it */ destroyPixi(): void { if (this.pixiSprite) { this.pixiSprite.parent?.removeChild(this.pixiSprite); this.pixiSprite.destroy(); // Destroy the sprite this.pixiSprite = null; } } // Orbs are likely static, so no update method needed for now // update(deltaTime: number): void { // void deltaTime; // } } export default Orb;
```

# src/PlayerSerpent.ts

```ts
import * as PIXI from 'pixi.js'; // Import PixiJS import { Point, Segment, Velocity, SnakeState, PLAYER_INITIAL_SPEED, PLAYER_INITIAL_LENGTH, PLAYER_INITIAL_SEGMENTS, PLAYER_COLOR, // RGBA array [r, g, b, a] (0-1 range) PLAYER_MAX_ADDITIONAL_SPEED, // Added PLAYER_SPEED_LENGTH_FACTOR, // Added // KEYBOARD_TURN_COOLDOWN_MS, // Removed unused import // JOYSTICK_TURN_COOLDOWN_MS, SAFE_PX, MAX_NECK_SKIP_SEGMENTS, segRadius, // Import eating constants PLAYER_EAT_SPEED_BOOST, PLAYER_EAT_SPEED_BOOST_DURATION_MS, PLAYER_EAT_GLOW_FRAMES, PLAYER_LENGTH_PER_ORB // WORLD_WIDTH, WORLD_HEIGHT removed from imports } from './types'; import { dist } from './utils'; // Ensure dist is imported // // Helper function to position 'current' exactly 'distance' behind 'target' // REMOVED UNUSED // function moveTowards(target: Point, current: Point, distance: number): Point { // const dx = current.x - target.x; // Vector from target to current // const dy = current.y - target.y; // const len = Math.hypot(dx, dy); // if (len === 0) return { ...current }; // Avoid division by zero if points are coincident // // Calculate the scale factor to make the vector length exactly 'distance' // const scale = distance / len; // // Calculate the new position by adding the scaled vector to the target's position // return { x: target.x + dx * scale, y: target.y + dy * scale }; // } /** Helper function to wrap coordinates within the torus world */ function wrap(p: Point, worldWidth: number, worldHeight: number): Point { const halfWidth = worldWidth / 2; const halfHeight = worldHeight / 2; let { x, y } = p; // Destructure for modification if (x > halfWidth) { x -= worldWidth; } else if (x < -halfWidth) { x += worldWidth; } if (y > halfHeight) { y -= worldHeight; } else if (y < -halfHeight) { y += worldHeight; } return { x, y }; } /** Helper function to calculate the shortest delta on a torus */ function torusDelta(target: Point, current: Point, worldWidth: number, worldHeight: number): [number, number] { const halfWidth = worldWidth / 2; const halfHeight = worldHeight / 2; let dx = target.x - current.x; let dy = target.y - current.y; // Adjust delta for wrapping if (dx > halfWidth) { dx -= worldWidth; } else if (dx < -halfWidth) { dx += worldWidth; } if (dy > halfHeight) { dy -= worldHeight; } else if (dy < -halfHeight) { dy += worldHeight; } return [dx, dy]; } /** Torus-aware version of moveTowards */ function moveTowardsTorus(target: Point, current: Point, distance: number, worldWidth: number, worldHeight: number): Point { // Calculate the shortest path delta from current *to* target (away from head) const [dx, dy] = torusDelta(current, target, worldWidth, worldHeight); // Swapped target/current // Calculate the length of this shortest path vector const len = Math.hypot(dx, dy) || 1; // Use || 1 to prevent division by zero // Calculate the scale factor to make the vector length exactly 'distance' const scale = distance / len; // Calculate the new position by adding the scaled shortest path vector to the *target* point's position // This ensures the segment is placed 'distance' away from the target (segment ahead) return wrap( { x: target.x + dx * scale, y: target.y + dy * scale }, worldWidth, worldHeight ); } // Represents the player-controlled serpent, implementing the SnakeState interface export class PlayerSerpent implements SnakeState { // --- SnakeState Properties --- id: string | number; segs: Segment[]; velocity: Velocity; speed: number; length: number; color: number; // Use hex number format directly isPlayer: boolean; visible: boolean; name: string; // Added name property // --- Additional Player-Specific Properties --- private lastTurnTimestamp: number = 0; public eatQueue: { distanceTraveled: number, growthAmount: number }[] = []; // Tracks pulse and associated growth public glowFrames: number = 0; // Counter for temporary post-eating glow effect public speedBoostTimer: number = 0; // Timer for temporary speed boost (in seconds) - Made public public baseSpeed: number; // To store the speed before boost - Made public public score: number = 0; // Added score property // Removed growthPending field // Removed distAccumulator private readonly segmentGrowthDuration = 0.5; // Seconds for a segment to grow fully // --- PixiJS Integration --- public pixiObject: PIXI.Graphics | null = null; // PixiJS display object constructor(startX: number, startY: number) { this.id = 'player'; this.isPlayer = true; this.visible = true; this.color = PLAYER_COLOR; this.baseSpeed = PLAYER_INITIAL_SPEED; // Initialize baseSpeed this.speed = this.baseSpeed; // Initialize speed from baseSpeed this.length = PLAYER_INITIAL_LENGTH; this.velocity = { vx: 1, vy: 0 }; // Start moving right this.segs = []; this.name = "Player"; // Initialize player name this.score = 0; // Initialize score // Spread initial segments horizontally to prevent immediate self-collision const spacing = segRadius(this.length) * 2; // Space based on segment diameter for (let i = 0; i < PLAYER_INITIAL_SEGMENTS; i++) { // Offset each segment to the left of the previous one this.segs.push({ x: startX - i * spacing, y: startY }); } // Removed collisionImmunityFrames initialization console.log(`PlayerSerpent created at (${startX}, ${startY}) with spaced segments.`); } // --- PixiJS Methods --- /** Initializes the PixiJS Graphics object for the serpent */ initPixi(stage: PIXI.Container): void { if (this.pixiObject) { this.destroyPixi(); // Clean up if already initialized } this.pixiObject = new PIXI.Graphics(); this.pixiObject.visible = this.visible; // Set initial position (optional, syncPixi will handle it) // this.pixiObject.position.set(this.segs[0].x, this.segs[0].y); stage.addChild(this.pixiObject); console.log(`PlayerSerpent Pixi object initialized and added to stage.`); } /** * Updates the PixiJS Graphics object to match the serpent's current state. * Includes dynamic styling for safe neck and eating pulses. * @param playerSkipCount The number of neck segments to style differently. * @param worldWidth Current dynamic world width. * @param worldHeight Current dynamic world height. */ syncPixi(playerSkipCount: number, worldWidth: number, worldHeight: number): void { if (!this.pixiObject) return; this.pixiObject.visible = this.visible; if (!this.visible || this.segs.length === 0) { this.pixiObject.clear(); // Clear if not visible or no segments return; } const graphics = this.pixiObject; graphics.clear(); const radius = segRadius(this.length); const bodyWidth = radius * 2; const headRadius = radius * 1.2; // Slightly larger head const baseHexColor = this.color; // Base color from state const baseAlpha = 1.0; // Base alpha // Define base effect properties const baseOutlineColor = 0xffffff; // White outline const basePlayerGlowColor = 0xFFFF00; // Yellow glow const basePlayerGlowStrength = 9; // Glow thickness offset const baseGlowAlpha = 0.25; const safeNeckColor = 0x0099aa; // Distinct color for safe neck const safeNeckGlowStrength = 3; // Reduced glow for safe neck const pulseColor = 0xffffff; // White flash for pulse const pulseGlowBoost = 4; // Extra glow strength during pulse const pulseWidthMultiplier = 0.5; // How much swellFactor affects width (0.5 = 50%) // --- Draw Body (Layered Segment Connections) --- // Stop one segment earlier to handle the final connection + tail bulb separately if (this.segs.length > 1) { for (let i = 0; i < this.segs.length - 2; i++) { // Stop at length - 2 const startSeg = this.segs[i]; const endSeg = this.segs[i + 1]; // --- Calculate segment-specific state --- const segmentLength = dist(startSeg, endSeg); let cumulativeDistanceToStart = 0; for(let j = 0; j < i; j++) { cumulativeDistanceToStart += dist(this.segs[j], this.segs[j+1]); } const segmentMidpointDistance = cumulativeDistanceToStart + segmentLength / 2; let swellFactor = 0; const pulseWaveWidth = segRadius(this.length) * 8; for (const pulse of this.eatQueue) { const distFromPulseCenter = Math.abs(segmentMidpointDistance - pulse.distanceTraveled); if (distFromPulseCenter < pulseWaveWidth / 2) { swellFactor = Math.max(swellFactor, 1 - (distFromPulseCenter / (pulseWaveWidth / 2))); } } const isPulsing = swellFactor > 0.01; const isSafePlayerSegment = this.isPlayer && playerSkipCount > 0 && i < playerSkipCount; // --- Determine conditional styles --- // Get growth progress for the end segment (the one potentially growing) // Also consider the start segment's growth for smoother connection appearance const startGrowth = startSeg.growthProgress ?? 1.0; const endGrowth = endSeg.growthProgress ?? 1.0; const avgGrowth = (startGrowth + endGrowth) / 2; // Average growth for the connection const finalBaseWidth = bodyWidth * (1 + swellFactor * pulseWidthMultiplier); const currentBaseWidth = finalBaseWidth * avgGrowth; // Scale width by average growth const currentOutlineWidth = currentBaseWidth + 2 * avgGrowth; // Scale outline addition too const currentAlpha = baseAlpha * avgGrowth; // Fade in alpha based on average growth let currentGlowWidth: number; let currentGlowColor: number; let currentBodyColor: number; const baseColorWithGlow = this.glowFrames > 0 ? 0xffffff : baseHexColor; if (isSafePlayerSegment) { currentBodyColor = safeNeckColor; currentGlowColor = safeNeckColor; currentGlowWidth = currentBaseWidth + safeNeckGlowStrength * avgGrowth * (1 + swellFactor * pulseWidthMultiplier); // Scale glow strength by growth } else { currentBodyColor = isPulsing ? pulseColor : baseColorWithGlow; currentGlowColor = basePlayerGlowColor; const currentGlowStrength = isPulsing ? (basePlayerGlowStrength + pulseGlowBoost) : basePlayerGlowStrength; currentGlowWidth = currentBaseWidth + currentGlowStrength * avgGrowth * (1 + swellFactor * pulseWidthMultiplier); // Scale glow strength by growth } // --- Check for World Wrap --- const isWrapX = Math.abs(startSeg.x - endSeg.x) > worldWidth / 2; const isWrapY = Math.abs(startSeg.y - endSeg.y) > worldHeight / 2; const isWrap = isWrapX || isWrapY; // --- Draw Layers (only if not wrapping and segment has started growing) --- if (!isWrap && currentBaseWidth > 0.1) { // Avoid drawing near-zero width lines // 1. Draw Outline Layer graphics.stroke({ width: currentOutlineWidth, color: baseOutlineColor, alpha: currentAlpha, // Use interpolated alpha cap: 'round', join: 'round' }); graphics.moveTo(startSeg.x, startSeg.y); graphics.lineTo(endSeg.x, endSeg.y); graphics.stroke(); // 2. Draw Glow Layer graphics.stroke({ width: currentGlowWidth, color: currentGlowColor, alpha: baseGlowAlpha * avgGrowth, // Scale glow alpha by average growth cap: 'round', join: 'round' }); graphics.moveTo(startSeg.x, startSeg.y); graphics.lineTo(endSeg.x, endSeg.y); graphics.stroke(); // 3. Draw Main Body Layer graphics.stroke({ width: currentBaseWidth, color: currentBodyColor, alpha: currentAlpha, // Use interpolated alpha cap: 'round', join: 'round' }); graphics.moveTo(startSeg.x, startSeg.y); graphics.lineTo(endSeg.x, endSeg.y); graphics.stroke(); } } } else if (this.segs.length === 1) { // Handle drawing just the head if only one segment exists } // --- Draw Final Segment Connection & Tail Bulb --- if (this.segs.length >= 2) { const penultimateSeg = this.segs[this.segs.length - 2]; const tailSeg = this.segs[this.segs.length - 1]; const tailGrowth = tailSeg.growthProgress ?? 1.0; // Growth of the *last* segment // Calculate styles based *only* on the tail's growth const tailBaseWidth = bodyWidth * tailGrowth; const tailOutlineWidth = tailBaseWidth + 2 * tailGrowth; const tailAlpha = baseAlpha * tailGrowth; const tailColor = this.glowFrames > 0 ? 0xffffff : baseHexColor; // Consider glowFrames // Use standard glow for the final segment unless pulsing affects it? // For simplicity, let's use standard glow for now. const tailGlowColor = basePlayerGlowColor; const tailGlowWidth = tailBaseWidth + basePlayerGlowStrength * tailGrowth; const tailGlowAlpha = baseGlowAlpha * tailGrowth; // Check for wrap between penultimate and tail const isWrapX = Math.abs(penultimateSeg.x - tailSeg.x) > worldWidth / 2; const isWrapY = Math.abs(penultimateSeg.y - tailSeg.y) > worldHeight / 2; const isWrap = isWrapX || isWrapY; // Draw Connection Layers only if the tail segment is mostly grown (> 85%) if (!isWrap && tailGrowth > 0.85 && tailBaseWidth > 0.1) { // 1. Outline graphics.stroke({ width: tailOutlineWidth, color: baseOutlineColor, alpha: tailAlpha, cap: 'round', join: 'round' }); graphics.moveTo(penultimateSeg.x, penultimateSeg.y); graphics.lineTo(tailSeg.x, tailSeg.y); graphics.stroke(); // 2. Glow graphics.stroke({ width: tailGlowWidth, color: tailGlowColor, alpha: tailGlowAlpha, cap: 'round', join: 'round' }); graphics.moveTo(penultimateSeg.x, penultimateSeg.y); graphics.lineTo(tailSeg.x, tailSeg.y); graphics.stroke(); // 3. Body graphics.stroke({ width: tailBaseWidth, color: tailColor, alpha: tailAlpha, cap: 'round', join: 'round' }); graphics.moveTo(penultimateSeg.x, penultimateSeg.y); graphics.lineTo(tailSeg.x, tailSeg.y); graphics.stroke(); } // Draw Tail Bulb (always draw if tail exists and is growing, even if connection wrapped) // Ensure a minimum radius of 1 pixel for visibility const tailRadius = Math.max(radius * tailGrowth, 1); if (tailRadius > 0.1) { // Keep the > 0.1 check for consistency, though Math.max ensures it's >= 1 // Draw bulb layers (similar structure to head, but simpler) // 1. Outline (optional, maybe just fill?) // graphics.circle(tailSeg.x, tailSeg.y, tailRadius + 1 * tailGrowth); // graphics.stroke({ width: 1 * tailGrowth, color: baseOutlineColor, alpha: tailAlpha }); // 2. Glow (optional) // graphics.circle(tailSeg.x, tailSeg.y, tailRadius + (basePlayerGlowStrength / 2) * tailGrowth); // graphics.fill({ color: tailGlowColor, alpha: tailGlowAlpha }); // 3. Fill (Main Bulb) graphics.circle(tailSeg.x, tailSeg.y, tailRadius); graphics.fill({ color: tailColor, alpha: tailAlpha }); } } // --- Draw Head (Layered) --- const headSeg = this.segs[0]; // Head doesn't "grow" in the same way, but we check just in case const headGrowth = headSeg.growthProgress ?? 1.0; const currentHeadRadius = headRadius * headGrowth; if (currentHeadRadius > 0.1) { // Only draw if radius is significant const headColor = this.glowFrames > 0 ? 0xffffff : baseHexColor; const headGlowStrength = basePlayerGlowStrength + 2; const currentHeadGlowRadius = currentHeadRadius + (headGlowStrength / 2) * headGrowth; const currentHeadOutlineRadius = currentHeadRadius + 1 * headGrowth; const currentHeadAlpha = baseAlpha * headGrowth; // 1. Head Outline graphics.circle(headSeg.x, headSeg.y, currentHeadOutlineRadius); graphics.stroke({ width: 2 * headGrowth, color: baseOutlineColor, alpha: currentHeadAlpha }); // 2. Head Glow graphics.circle(headSeg.x, headSeg.y, currentHeadGlowRadius); graphics.fill({ color: basePlayerGlowColor, alpha: baseGlowAlpha * headGrowth }); // 3. Head Fill graphics.circle(headSeg.x, headSeg.y, currentHeadRadius); graphics.fill({ color: headColor, alpha: currentHeadAlpha }); // --- Draw Eyes (Layered and Oriented) --- const finalEyeRadius = Math.max(2 * headGrowth, currentHeadRadius * 0.2); const eyeDist = currentHeadRadius * 0.5; const eyeAngle = Math.atan2(this.velocity.vy, this.velocity.vx); const eyeAnglePerp = eyeAngle + Math.PI / 2; const eye1X = headSeg.x + Math.cos(eyeAnglePerp) * eyeDist; const eye1Y = headSeg.y + Math.sin(eyeAnglePerp) * eyeDist; const eye2X = headSeg.x - Math.cos(eyeAnglePerp) * eyeDist; const eye2Y = headSeg.y - Math.sin(eyeAnglePerp) * eyeDist; const eyeGlowColor = 0xffffff; const eyeGlowAlpha = 0.15 * headGrowth; const eyeGlowRadius = finalEyeRadius + 2 * headGrowth; const eyeFillColor = 0x000000; const eyeFillAlpha = 0.9 * headGrowth; // Eye 1 Glow graphics.circle(eye1X, eye1Y, eyeGlowRadius); graphics.fill({ color: eyeGlowColor, alpha: eyeGlowAlpha }); // Eye 2 Glow graphics.circle(eye2X, eye2Y, eyeGlowRadius); graphics.fill({ color: eyeGlowColor, alpha: eyeGlowAlpha }); // Eye 1 Fill graphics.circle(eye1X, eye1Y, finalEyeRadius); graphics.fill({ color: eyeFillColor, alpha: eyeFillAlpha }); // Eye 2 Fill graphics.circle(eye2X, eye2Y, finalEyeRadius); graphics.fill({ color: eyeFillColor, alpha: eyeFillAlpha }); } // --- Tail Bulb drawing moved to the dedicated pass above --- // if (this.segs.length > 0) { // const tail = this.segs[this.segs.length - 1]; // const tailGrowth = tail.growthProgress ?? 1; // Default to 1 if not growing // const tailR = radius * tailGrowth; // Scale radius by growth // if (tailR > 0.1) { // Only draw if radius is significant // // Use base color and alpha, potentially affected by glowFrames // const tailColor = this.glowFrames > 0 ? 0xffffff : baseHexColor; // const tailAlpha = baseAlpha * tailGrowth; // Fade in alpha // graphics.circle(tail.x, tail.y, tailR); // graphics.fill({ color: tailColor, alpha: tailAlpha }); // // Optional: Add outline/glow similar to body/head if desired // } // } } /** Removes the PixiJS object from the stage and destroys it */ destroyPixi(): void { if (this.pixiObject) { this.pixiObject.parent?.removeChild(this.pixiObject); this.pixiObject.destroy({ children: true }); // Destroy graphics object this.pixiObject = null; console.log("PlayerSerpent Pixi object destroyed."); } } // --- Existing Methods (No changes needed below for PixiJS integration) --- setDirection(dx: number, dy: number): void { const magnitude = Math.hypot(dx, dy); if (magnitude > 0.01) { this.velocity.vx = dx / magnitude; this.velocity.vy = dy / magnitude; } } attemptTurn(desiredDir: Point, currentTimestamp: number, turnCooldown: number): boolean { if (currentTimestamp - this.lastTurnTimestamp <= turnCooldown) { return false; } const dotProduct = desiredDir.x * this.velocity.vx + desiredDir.y * this.velocity.vy; if (dotProduct < -0.9) { return false; } const head = this.segs[0]; const predictStep = this.speed * 1.5; const nextX = head.x + desiredDir.x * predictStep; const nextY = head.y + desiredDir.y * predictStep; const skipCount = this.calculateSkipSegments(); const wouldBite = this.willHitTail(nextX, nextY, skipCount); if (wouldBite) { return false; } this.velocity.vx = desiredDir.x; this.velocity.vy = desiredDir.y; this.lastTurnTimestamp = currentTimestamp; return true; } // Made public to be accessible from Game.ts for rendering logic public calculateSkipSegments(): number { if (this.speed <= 0) return MAX_NECK_SKIP_SEGMENTS; const links = Math.round(SAFE_PX / this.speed); return Math.min(links, MAX_NECK_SKIP_SEGMENTS); } // Made public for self-collision check in Game.ts public willHitTail(checkX: number, checkY: number, skipCount: number): boolean { // Removed immunity check const checkPoint: Point = { x: checkX, y: checkY }; const threshold = segRadius(this.length) + 1; let startCheckIndex = Math.min(skipCount, this.segs.length - 1); // Ensure we ALWAYS skip at least the first few segments immediately behind the head (indices 1, 2, 3, 4, 5) // for the post-movement check. This prevents instant game over at start. startCheckIndex = Math.max(startCheckIndex, 6); // Start checking from index 6 AT LEAST. // Ensure loop doesn't run if startCheckIndex is out of bounds or too low if (startCheckIndex >= this.segs.length || startCheckIndex < 1) { // Cannot collide with head (index 0) return false; } // Removed PreCheck logging for (let i = startCheckIndex; i < this.segs.length; i++) { const segmentToCheck = this.segs[i]; // Ensure segmentToCheck is valid before calculating distance if (!segmentToCheck || typeof segmentToCheck.x !== 'number' || typeof segmentToCheck.y !== 'number') { // console.error(`[willHitTail] Invalid segment at index ${i}:`, segmentToCheck); // Keep commented continue; // Skip this segment } const distance = dist(checkPoint, segmentToCheck); // console.log(`[willHitTail] Checking head (${checkPoint.x.toFixed(2)}, ${checkPoint.y.toFixed(2)}) vs seg[${i}] (${segmentToCheck.x.toFixed(2)}, ${segmentToCheck.y.toFixed(2)}). Dist: ${distance.toFixed(2)}, Threshold: ${threshold.toFixed(2)}`); // Keep commented if (distance < threshold) { // console.error(`[willHitTail] Collision DETECTED! Head (${checkPoint.x.toFixed(2)}, ${checkPoint.y.toFixed(2)}) vs seg[${i}] (${segmentToCheck.x.toFixed(2)}, ${segmentToCheck.y.toFixed(2)}). Dist: ${distance.toFixed(2)}, Threshold: ${threshold.toFixed(2)}`); // Keep commented return true; } } return false; } // Removed willHitTail as it's not directly needed for this step's rendering logic // private willHitTail /** Called when the player eats an orb */ eatOrb(orbValue: number): void { console.log(`Player ate orb with value: ${orbValue}`); // Increase logical length const growth = orbValue * PLAYER_LENGTH_PER_ORB; this.length += growth; // logical length this.score += orbValue; // 🆕 track points here // Add pulse wave starting at the head, carrying the growth amount this.eatQueue.push({ distanceTraveled: 0, growthAmount: growth }); // Set glow frames this.glowFrames = PLAYER_EAT_GLOW_FRAMES; // Use constant from types.ts // Apply speed boost (Boost is now applied on top of the current baseSpeed) this.speed = this.baseSpeed * PLAYER_EAT_SPEED_BOOST; // Use updated constant this.speedBoostTimer = PLAYER_EAT_SPEED_BOOST_DURATION_MS / 1000; // Use updated constant console.log(`Speed boosted to ${this.speed.toFixed(1)} for ${this.speedBoostTimer.toFixed(2)}s (Base: ${this.baseSpeed.toFixed(1)})`); } update(deltaTime: number, worldWidth: number, worldHeight: number): void { // Add world dimensions if (!this.visible) return; // --- Update Base Speed based on Length (Diminishing Returns) --- // Calculate the target speed based on length const lengthContribution = PLAYER_MAX_ADDITIONAL_SPEED * (1 - Math.exp(-(this.length - PLAYER_INITIAL_LENGTH) * PLAYER_SPEED_LENGTH_FACTOR)); const targetBaseSpeed = PLAYER_INITIAL_SPEED + Math.max(0, lengthContribution); // Ensure it doesn't go below initial // Smoothly adjust baseSpeed towards targetBaseSpeed (optional, direct set for now) // const speedAdjustRate = 0.1; // Adjust this for smoothness // this.baseSpeed += (targetBaseSpeed - this.baseSpeed) * speedAdjustRate * deltaTime; this.baseSpeed = targetBaseSpeed; // Direct set // --- Update Effects --- // Speed Boost Timer & Tapering const maxBoostAmount = this.baseSpeed * (PLAYER_EAT_SPEED_BOOST - 1); const totalBoostDuration = PLAYER_EAT_SPEED_BOOST_DURATION_MS / 1000; if (this.speedBoostTimer > 0) { this.speedBoostTimer -= deltaTime; if (this.speedBoostTimer <= 0) { this.speed = this.baseSpeed; // Ensure speed is exactly baseSpeed when timer ends this.speedBoostTimer = 0; // console.log(`Speed boost ended. Speed reset to base: ${this.baseSpeed.toFixed(1)}`); // Less verbose logging } else { // Calculate remaining boost fraction (linear taper) const boostFraction = this.speedBoostTimer / totalBoostDuration; // Apply tapered boost on top of the current base speed this.speed = this.baseSpeed + maxBoostAmount * boostFraction; } } else { // Ensure speed matches baseSpeed if no boost is active this.speed = this.baseSpeed; } // Glow Frames Timer if (this.glowFrames > 0) { this.glowFrames--; } // Removed Collision Immunity Timer decrement // --- Movement --- const moveDistance = this.speed * deltaTime; // Update Eat Queue and Trigger Growth at Tail const currentLengthPixels = this.calculateLengthPixels(); // Get current pixel length before moving segments const completedPulsesIndices: number[] = []; this.eatQueue.forEach((pulse, index) => { pulse.distanceTraveled += moveDistance; // Check if pulse has reached or passed the current tail end if (pulse.distanceTraveled >= currentLengthPixels) { // Trigger segment growth for (let g = 0; g < pulse.growthAmount; g++) { if (this.segs.length > 0) { // Ensure snake exists const tailIndex = this.segs.length - 1; const tail = this.segs[tailIndex]; // Spawn the new segment *at* the current tail's position (collapsed) this.segs.push({ x: tail.x, y: tail.y, isGrowing: true, growthProgress: 0 }); } } completedPulsesIndices.push(index); // Mark pulse for removal } }); // Remove completed pulses (iterate backwards to avoid index issues) for (let i = completedPulsesIndices.length - 1; i >= 0; i--) { this.eatQueue.splice(completedPulsesIndices[i], 1); } // --- Update Segment Growth Animations --- const growthIncrement = deltaTime / this.segmentGrowthDuration; this.segs.forEach(seg => { if (seg.isGrowing) { // Ensure growthProgress is initialized if undefined seg.growthProgress = (seg.growthProgress ?? 0) + growthIncrement; if (seg.growthProgress >= 1) { seg.growthProgress = 1; // Clamp to 1 seg.isGrowing = false; // Mark growth as complete } } }); // --- Head Movement --- // Calculate the new head position based on velocity and moveDistance first const originalHead = this.segs[0]; let newHead: Point = { x: originalHead.x + this.velocity.vx * moveDistance, y: originalHead.y + this.velocity.vy * moveDistance, }; // Apply World Wrapping to the new head position using the helper function newHead = wrap(newHead, worldWidth, worldHeight); // --- Segment Management (Constant Spacing) --- // Update the head segment first this.segs[0] = newHead; // Now, update body segments to maintain constant spacing from the one ahead // Lock base spacing to initial diameter so snake adds links instead of stretching const baseSegmentSpacing = segRadius(PLAYER_INITIAL_LENGTH) * 2; for (let i = 1; i < this.segs.length; i++) { // Scale the desired spacing based on the *average* growth progress of the current and previous segment const currGp = this.segs[i].growthProgress ?? 1; const prevGp = this.segs[i - 1]?.growthProgress ?? 1; // Use optional chaining for safety, default to 1 const avgGp = (currGp + prevGp) * 0.5; const desiredSpacing = baseSegmentSpacing * avgGp; // Position segment i exactly desiredSpacing behind segment i-1 using torus logic const newSegPos = moveTowardsTorus(this.segs[i - 1], this.segs[i], desiredSpacing, worldWidth, worldHeight); // Wrap the segment position after calculating it (moveTowardsTorus already wraps, but double-checking is safe) this.segs[i] = wrap(newSegPos, worldWidth, worldHeight); } // --- Manage Length --- // Length is now managed implicitly by pulses reaching the tail and adding segments. // No explicit removal needed unless a shrinking mechanic is implemented. // Collision checks are handled in Game.ts after updates. } /** Calculates the approximate pixel length of the serpent based on segment distances */ private calculateLengthPixels(): number { let totalDistance = 0; if (this.segs.length < 2) { return 0; // No length if less than 2 segments } for (let i = 0; i < this.segs.length - 1; i++) { totalDistance += dist(this.segs[i], this.segs[i+1]); } return totalDistance; } } export default PlayerSerpent;
```

# src/Serpent.ts

```ts
export {};
```

# src/types.ts

```ts
// --- Core Data Structures --- /** Represents a 2D point or vector */ export interface Point { x: number; y: number; } /** Represents a segment of the snake's body */ export interface Segment extends Point { isGrowing?: boolean; // Is the segment currently in its growth animation? growthProgress?: number; // Animation progress (0 to 1) } /** Represents the snake's current movement vector */ export interface Velocity { vx: number; vy: number; } /** * Represents the state of a single snake. * Adapted for the NeonSerpent WebGL game. */ export interface SnakeState { id: string | number; // Unique identifier (using 0 for player for now) segs: Segment[]; // Array of segments, head is at index 0 velocity: Velocity; // Current direction of movement speed: number; // Current movement speed (pixels per update/second) length: number; // Logical length (used for radius calculations, might differ from segs.length) color: number; // Base color as a hex number (e.g., 0xRRGGBB) isPlayer: boolean; // Flag indicating if this is the player's snake // --- Simplified/Deferred properties from original code --- // glowFrames: number; // Counter for temporary post-eating glow effect (Deferred) // eatQueue: number[]; // Positions of active eating "pulse" animations along the body (Deferred) visible: boolean; // Should this snake be rendered? name: string; // Added name property score: number; // Added score property (ensure it's here) // Add other state as needed (e.g., power-ups) } // --- World Constants --- // World size is now dynamic, calculated in Game.ts based on screen size and zoom export const WORLD_PADDING = 50; // Pixels from the edge of the visible zoomed video // --- Player Constants --- // These might move to a dedicated constants.ts file later export const PLAYER_INITIAL_SPEED = 45; // Base speed (pixels per second) export const PLAYER_MAX_ADDITIONAL_SPEED = 100; // Increased max speed increase from length (was 60) export const PLAYER_SPEED_LENGTH_FACTOR = 0.008; // Slightly reduced factor for slower ramp-up (was 0.01) export const PLAYER_INITIAL_LENGTH = 10; export const PLAYER_INITIAL_SEGMENTS = 10; export const PLAYER_COLOR: number = 0x00FF00; // Green in hex format // --- Eating & Effects Constants --- export const PLAYER_EAT_SPEED_BOOST = 2.0; // Multiplier for speed boost peak export const PLAYER_EAT_SPEED_BOOST_DURATION_MS = 750; // Increased duration (was 350) export const PLAYER_EAT_GLOW_FRAMES = 15; // How many frames the body glow lasts export const PLAYER_LENGTH_PER_ORB = 1; // How much logical length increases per orb // --- Movement & Collision Constants --- export const KEYBOARD_TURN_COOLDOWN_MS = 100; // Milliseconds between keyboard turns export const JOYSTICK_TURN_COOLDOWN_MS = 50; // Milliseconds between joystick turns (shorter) export const SAFE_PX = 192; // Safety distance behind head for self-collision checks export const MAX_NECK_SKIP_SEGMENTS = 60; // Max segments to ignore for self-collision // Helper function adapted from provided code /** * Calculates the approximate visual radius of a snake segment based on its length. * Reduced by ~50% */ export function segRadius(snakeLength: number): number { // Reduced base radius and scaling factor for smaller snake // Start at 4px and increase slightly with length return 4 + snakeLength / 80; } // ---- Orb sizing ---- // Minimum visual radius in px (sprite will be diameter = radius * 2) export const ORB_BASE_RADIUS = 12; // Multiplier relative to the starting snake segment radius — lets us scale with future tweaks export const ORB_RADIUS_MULTIPLIER = 3; // --- Orb Constants --- export enum OrbTier { LOW, MID, HIGH } export interface OrbTierConfig { value: number; color: number; // Hex color spawnWeight: number; // Relative probability weight } export const ORB_TIER_CONFIG: Record<OrbTier, OrbTierConfig> = { [OrbTier.LOW]: { value: 1, color: 0x8888FF, spawnWeight: 6 }, // Light Blue, 60% [OrbTier.MID]: { value: 3, color: 0xFF88FF, spawnWeight: 3 }, // Pink, 30% [OrbTier.HIGH]: { value: 5, color: 0xFFFF88, spawnWeight: 1 }, // Light Yellow, 10% }; // Calculate total weight for weighted random selection export const ORB_TOTAL_SPAWN_WEIGHT = Object.values(ORB_TIER_CONFIG).reduce((sum, tier) => sum + tier.spawnWeight, 0); // Mapping from Orb Tier to its texture path export const ORB_TEXTURE: Record<OrbTier, string> = { [OrbTier.LOW]: '/orb1.png', [OrbTier.MID]: '/orb2.png', [OrbTier.HIGH]: '/orb3.png' }; // Add other shared types or constants as needed
```

# src/UI.ts

```ts
// Define potential game states or actions triggered by UI export type UIAction = | 'startGame' | 'showControls' | 'hideControls' | 'resumeGame' | 'pauseGame' // Although pause might be triggered by key press, menu could confirm | 'newGameFromPause' | 'newGameFromGameOver' // | 'showScoreboard' // Placeholder for original scoreboard button if needed | 'toggleDevMode'; // Callback type for UI actions export type UIActionCallback = (action: UIAction) => void; export class UIManager { // Menu Containers private mainMenu: HTMLElement | null = null; private controlsMenu: HTMLElement | null = null; private pauseMenu: HTMLElement | null = null; private gameOverMenu: HTMLElement | null = null; private loadingScreen: HTMLElement | null = null; // Keep track of loading screen private pauseLeaderboardList: HTMLElement | null = null; // Added for in-game leaderboard private inGameMiniBoard: HTMLElement | null = null; // Score Display private finalScoreElement: HTMLElement | null = null; // Callback for notifying the game logic private actionCallback: UIActionCallback; constructor(callback: UIActionCallback) { this.actionCallback = callback; } init(): void { // Get menu elements this.mainMenu = document.getElementById('mainMenu'); this.controlsMenu = document.getElementById('controlsMenu'); this.pauseMenu = document.getElementById('pauseMenu'); this.gameOverMenu = document.getElementById('gameOverMenu'); this.loadingScreen = document.getElementById('loadingScreen'); this.finalScoreElement = document.getElementById('finalScore'); this.pauseLeaderboardList = document.getElementById('pauseLeaderboardList'); // Get pause leaderboard list this.inGameMiniBoard = document.getElementById('inGameLeaderboard'); // Basic validation if (!this.mainMenu || !this.controlsMenu || !this.pauseMenu || !this.gameOverMenu || !this.loadingScreen || !this.finalScoreElement || !this.pauseLeaderboardList) { console.error('UIManager: Failed to find one or more required UI elements!'); // Don't return here, just warn about missing mini-board if applicable // return; } if (!this.inGameMiniBoard) console.warn('#inGameLeaderboard missing'); // --- Attach Button Listeners --- // Main Menu Buttons this.attachListener('startGameBtn', () => this.actionCallback('startGame')); this.attachListener('controlsBtnMain', () => this.actionCallback('showControls')); // Scoreboard button is placeholder for now - Re-add if needed, or use the new ID if keeping the button // this.attachListener('showLeaderboardBtn', () => this.actionCallback('showLeaderboard')); // Example if keeping button this.attachListener('scoreboardBtn', () => console.log('Scoreboard clicked (placeholder)')); // Original placeholder listener // Dev Mode Button this.attachListener('toggleDevModeBtn', () => this.actionCallback('toggleDevMode')); // Controls Menu Buttons this.attachListener('backToMainBtnControls', () => this.actionCallback('hideControls')); // Pause Menu Buttons this.attachListener('resumeGameBtn', () => this.actionCallback('resumeGame')); this.attachListener('newGameBtnPause', () => this.actionCallback('newGameFromPause')); this.attachListener('controlsBtnPause', () => this.actionCallback('showControls')); // Game Over Menu Buttons this.attachListener('mainMenuBtnGameOver', () => this.actionCallback('newGameFromGameOver')); // Or could be 'showMainMenu' console.log('UIManager initialized.'); // Initially, ensure only the main menu might be visible (or none if loading) // Actual visibility will be controlled by Game state later this.hideAllMenus(); } private attachListener(elementId: string, callback: () => void): void { const element = document.getElementById(elementId); if (element) { element.addEventListener('click', callback); } else { console.warn(`UIManager: Element with ID "${elementId}" not found.`); } } hideAllMenus(): void { this.mainMenu?.classList.add('hidden'); this.controlsMenu?.classList.add('hidden'); this.pauseMenu?.classList.add('hidden'); this.gameOverMenu?.classList.add('hidden'); } showMainMenu(): void { this.hideAllMenus(); this.mainMenu?.classList.remove('hidden'); } showControlsMenu(): void { // Show the controls menu and apply blur this.controlsMenu?.classList.remove('hidden'); this.controlsMenu?.classList.add('backdrop-blur'); // Add blur class } hideControlsMenu(): void { // Hide the controls menu and remove blur this.controlsMenu?.classList.add('hidden'); this.controlsMenu?.classList.remove('backdrop-blur'); // Remove blur class } showPauseMenu(): void { // Will be updated later to accept scores this.hideAllMenus(); // Usually pause takes over the screen this.pauseMenu?.classList.remove('hidden'); } showGameOverMenu(score: number): void { this.hideAllMenus(); if (this.finalScoreElement) { this.finalScoreElement.textContent = `Score: ${score}`; } this.gameOverMenu?.classList.remove('hidden'); } // --- Loading Screen --- hideLoadingScreen(): void { this.loadingScreen?.style.setProperty('display', 'none'); // Use setProperty for style changes } showLoadingScreen(message: string = 'Loading...'): void { if (this.loadingScreen) { this.loadingScreen.textContent = message; this.loadingScreen.style.setProperty('display', 'flex'); } } // --- In-Game Leaderboard Update --- updatePauseLeaderboard(scores: { name: string, score: number, isPlayer: boolean }[]): void { if (!this.pauseLeaderboardList) return; // Clear previous entries this.pauseLeaderboardList.innerHTML = ''; // Sort scores descending scores.sort((a, b) => b.score - a.score); // Populate with new scores (limit to top 10 or less) const topScores = scores.slice(0, 10); topScores.forEach(entry => { const li = document.createElement('li'); const nameSpan = document.createElement('span'); nameSpan.classList.add('leaderboard-name'); if (entry.isPlayer) { nameSpan.classList.add('player-score'); // Highlight player name } nameSpan.textContent = entry.name; const scoreSpan = document.createElement('span'); scoreSpan.classList.add('leaderboard-score'); if (entry.isPlayer) { scoreSpan.classList.add('player-score'); // Highlight player score } scoreSpan.textContent = entry.score.toString(); li.appendChild(nameSpan); li.appendChild(scoreSpan); this.pauseLeaderboardList?.appendChild(li); }); } // 🆕 live HUD (top 5) updateMiniLeaderboard(scores:{name:string,score:number,isPlayer:boolean}[]) { if(!this.inGameMiniBoard) return; // hide on small screens (CSS already does `display:none`) this.inGameMiniBoard.innerHTML = ''; scores.sort((a,b)=>b.score-a.score); scores.slice(0,5).forEach(e=>{ const div=document.createElement('div'); div.className='mini-row'+(e.isPlayer?' player':''); div.textContent=`${e.name} ${e.score}`; this.inGameMiniBoard!.appendChild(div); }); } } // Export the class and types // export {}; // No longer needed as class is exported
```

# src/utils.ts

```ts
import { Point } from './types'; /** Calculates Euclidean distance between two points */ export function dist(p1: Point, p2: Point): number { return Math.hypot(p1.x - p2.x, p1.y - p2.y); } /** Toroidal (wrapping) distance — shortest path across world edges */ export function distTorus(p1: Point, p2: Point, worldW: number, worldH: number): number { const halfW = worldW * 0.5, halfH = worldH * 0.5; let dx = Math.abs(p1.x - p2.x), dy = Math.abs(p1.y - p2.y); if (dx > halfW) dx = worldW - dx; if (dy > halfH) dy = worldH - dy; return Math.hypot(dx, dy); } // Add other utility functions here as needed
```

# src/vite-env.d.ts

```ts
/// <reference types="vite/client" /> declare module '*?raw' { const content: string; export default content; }
```

# src/World.ts

```ts
export {};
```

# tsconfig.json

```json
{ "compilerOptions": { /* Base Options: */ "esModuleInterop": true, "skipLibCheck": true, "target": "ESNext", "allowJs": false, "resolveJsonModule": true, "moduleDetection": "force", "isolatedModules": true, /* Strictness */ "strict": true, "noUnusedLocals": true, "noUnusedParameters": true, "noFallthroughCasesInSwitch": true, /* If NOT transpiling with TypeScript: */ "module": "ESNext", "noEmit": true, /* If your code runs in the DOM: */ "lib": ["ESNext", "DOM", "DOM.Iterable"], /* Module Resolution Options */ "moduleResolution": "bundler" // "baseUrl": ".", // "paths": {}, /* Source Map Options */ // "sourceMap": true, // "outDir": "./dist", // "rootDir": "./src", }, "include": ["src/**/*.ts"], "exclude": ["node_modules", "dist"] }
```

